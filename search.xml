<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java内存区域与内存溢出异常</title>
    <url>/2023/04/24/Java_nei_cun_qu_yu_yu_nei_cun_yi_chu_yi_chang/</url>
    <content><![CDATA[<blockquote>
<p>本文源于《深入理解Java虚拟机：JVM高级特性与最佳实践（第3版）》</p>
</blockquote>
<p>回答了自动内存管理的几个问题：</p>
<ol>
<li>内存是如何分布的？<ol>
<li>宏观的java虚拟机的运行时数据区</li>
<li>微观的hotspot虚拟机的对象</li>
</ol>
</li>
<li>为什么要这么分布？从内存分布以及各个区域oom的场景，我们可以窥见这么分布的好处。（模块化，各司其职）</li>
</ol>
<span id="more"></span>

<h2 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h2><blockquote>
<p>宏观上java虚拟机的内存分布</p>
</blockquote>
<h3 id="线程隔离的数据区："><a href="#线程隔离的数据区：" class="headerlink" title="线程隔离的数据区："></a>线程隔离的数据区：</h3><ul>
<li>程序计数器：作为程序控制流的指示器，用于控制当前线程将要执行的字节码指令对应的行数。</li>
<li>Java虚拟机栈：每个方法的执行与完成都是一个栈帧从压栈到出栈的过程。栈帧包含：局部变量表、操作数栈、动态链接、方法出口等信息。其中的局部变量表包含基本数据类型、对象引用、returnAddress。</li>
<li>本地方法栈：为虚拟机使用本地方法服务。</li>
</ul>
<p><img src="https://kanhaiblog-1315198027.cos.ap-shanghai.myqcloud.com/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA.png"></p>
<h3 id="由所有线程共享的数据区："><a href="#由所有线程共享的数据区：" class="headerlink" title="由所有线程共享的数据区："></a>由所有线程共享的数据区：</h3><ul>
<li>java堆：此内存区域唯一的目的就是存放对象实例与数组。几乎所有的对象都在这里分配，但在逃逸分析技术下通过栈上分配与标量替换，会让对象在栈上进行分配。注意堆在虚拟机规范中理论上仅分为普通堆与TLAB（每个线程私有的分配缓冲区）。</li>
<li>方法区：又称非堆。用于存储类型信息、常量、静态变量、即使编译器编译后的代码缓存等数据。<ul>
<li>运行时常量池：是方法区的一部分。存放编译期Class文件中的各种符号引用与字面量，同时运行期间产生的常量也可以放入常量池中，如String.intern()。注意1.7的hotspot虚拟机中，运行时常量池被放在java堆中。</li>
</ul>
</li>
</ul>
<h3 id="非java虚拟机定义的内存区域："><a href="#非java虚拟机定义的内存区域：" class="headerlink" title="非java虚拟机定义的内存区域："></a>非java虚拟机定义的内存区域：</h3><ul>
<li>直接内存：在NIO中的基于通道和缓冲区的IO方式，可以使用native函数直接分配堆外内存，然后通过存储在java堆中的direatByteBuffer对象引用这块内存进行操作。避免来回复制数据。其不受java堆大小限制，但受本地总内存限制。</li>
</ul>
<h2 id="hotspot虚拟机对象"><a href="#hotspot虚拟机对象" class="headerlink" title="hotspot虚拟机对象"></a>hotspot虚拟机对象</h2><blockquote>
<p>以下场景均在hotspot虚拟机下。<br>即微观下一个具体的虚拟机实现中，一个对象的内存分配</p>
</blockquote>
<h3 id="创建对象的过程："><a href="#创建对象的过程：" class="headerlink" title="创建对象的过程："></a>创建对象的过程：</h3><blockquote>
<p>（不包含数据与Class对象）</p>
</blockquote>
<ol>
<li>通过常量池定位类是否加载过，若无则先执行类加载过程。</li>
<li>分配内存：通过指针碰撞或者空闲列表的方式分配内存空间，这取决于内存是否规整，即内存收集器的算法。<ol>
<li>已启用TLAB：线程直接在对应的TLAB区域直接分配对象内存。</li>
<li>未启用TLAB：通过cas+失败重试机制，保证操作的原子性。</li>
</ol>
</li>
<li>初始化零值：<ol>
<li>启用TLAB：在为线程分配TLAB时可以直接初始化。</li>
<li>未启用TLAB：初始化零值。</li>
</ol>
</li>
<li>设置对象头：类型数据、类型指针、mark word等。如果启用偏向锁，则还要设置偏向的线程信息。</li>
<li>执行init方法，即构造函数。</li>
</ol>
<h3 id="对象的内存布局："><a href="#对象的内存布局：" class="headerlink" title="对象的内存布局："></a>对象的内存布局：</h3><ol>
<li>对象头<ol>
<li>运行时数据：Mark word，在不同状态下存储的数据不同：未锁定、偏向、轻量级锁定、重量级锁定、GC。见下图。</li>
<li>类型指针</li>
</ol>
</li>
<li>实例数据：包含父类与当前子类中定义的字段（即使父类的数据无权限访问）。</li>
<li>对齐填充</li>
</ol>
<p>注意：如果是数组，还要记录数组长度。</p>
<p><img src="https://kanhaiblog-1315198027.cos.ap-shanghai.myqcloud.com/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8/20230425013407424.png"></p>
<h3 id="对象的访问定位："><a href="#对象的访问定位：" class="headerlink" title="对象的访问定位："></a>对象的访问定位：</h3><blockquote>
<p>hotspot使用直接指针定位</p>
</blockquote>
<ul>
<li>如果使用句柄访问的话，Java堆中将可能会划分出一块内存来作为句柄池，reference中存储的就 是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自具体的地址信息.<ul>
<li>优点：垃圾收集后移动对象，此时reference无需修改，只要修改句柄的实例数据指针。</li>
</ul>
</li>
<li>如果使用直接指针访问的话，Java堆中对象的内存布局就必须考虑如何放置访问类型数据的相关 信息，reference中存储的直接就是对象地址，如果只是访问对象本身的话，就不需要多一次间接访问的开销<ul>
<li>优点：速度快，只需一次指针定位。<br><img src="https://kanhaiblog-1315198027.cos.ap-shanghai.myqcloud.com/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8/20230425013425517.png"></li>
</ul>
</li>
</ul>
<h2 id="实战OOM"><a href="#实战OOM" class="headerlink" title="实战OOM"></a>实战OOM</h2><blockquote>
<p>各个内存区域出现OOM异常</p>
</blockquote>
<h3 id="java-堆溢出："><a href="#java-堆溢出：" class="headerlink" title="java 堆溢出："></a>java 堆溢出：</h3><ul>
<li>内存泄漏：<ul>
<li>如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的引用链，找到泄漏对象是通过怎 样的引用路径、与哪些GC Roots相关联，才导致垃圾收集器无法回收它们，根据泄漏对象的类型信息 以及它到GC Roots引用链的信息，一般可以比较准确地定位到这些对象创建的位置，进而找出产生内存泄漏的代码的具体位置。</li>
</ul>
</li>
<li>内存溢出：<ul>
<li>如果不是内存泄漏，换句话说就是内存中的对象确实都是必须存活的，那就应当检查Java虚拟机 的堆参数（-Xmx与-Xms）设置，与机器的内存对比，看看是否还有向上调整的空间。再从代码上检查 是否存在某些对象生命周期过长、持有状态时间过长、存储结构设计不合理等情况，尽量减少程序运行期的内存消耗。</li>
</ul>
</li>
</ul>
<h3 id="虚拟机栈与本地方法栈溢出："><a href="#虚拟机栈与本地方法栈溢出：" class="headerlink" title="虚拟机栈与本地方法栈溢出："></a>虚拟机栈与本地方法栈溢出：</h3><blockquote>
<p>hotspot虚拟机栈中不区分二者。</p>
</blockquote>
<p>由于hotspot虚拟机不允许栈动态扩展，所以理论上只会出现容量不足而出现的StackOverFlowError。但如果创建线程时就无法获得足够内存，则会出现OOM。</p>
<ul>
<li>多线程场景下，为每个线程分配到的栈内存越大，可以建立的线程数量自然就越少，建立线程时就越容易把剩下的内存耗尽。</li>
</ul>
<h3 id="方法区和运行时常量池溢出："><a href="#方法区和运行时常量池溢出：" class="headerlink" title="方法区和运行时常量池溢出："></a>方法区和运行时常量池溢出：</h3><ul>
<li>1.6，hotspot采用永久代实现方法区，运行时常量池也在其中，不断生成常量会使运行时常量池溢出，即方法区溢出，即永久代溢出。</li>
<li>1.7 时，hotspot将运行时常量池移到java堆中。</li>
<li>1.8的hotspot虚拟机中，方法区通过元空间，在直接内存中实现，而运行时常量池在java堆中。</li>
</ul>
<p><strong>注意String.intern方法</strong>：1.6会把首次遇到的字符串实例复制到永久代的字符串常量池 中存储，返回的也是永久代里面这个字符串实例的引用；1.7之后，既然字符串常量池已经移到Java堆中，那只需要在常量池里记录一下首次出现的实例引用即可。</p>
<p><strong>问题： 1.8中的元空间会垃圾回收吗？</strong><br>答案：会。这里需要引出元空间的4个参数。</p>
<ul>
<li>-XX：MetaspaceSize：指定元空间的初始空间大小，以字节为单位，达到该值就会触发垃圾收集 进行类型卸载，同时收集器会对该值进行调整：如果释放了大量的空间，就适当降低该值；如果释放 了很少的空间，那么在不超过-XX：MaxMetaspaceSize（如果设置了的话）的情况下，适当提高该值。</li>
<li>-XX：MaxMetaspaceSize：设置元空间最大值，默认是-1，即不限制，或者说只受限于本地内存 大小。</li>
<li>-XX：MinMetaspaceFreeRatio：作用是在垃圾收集之后控制最小的元空间剩余容量的百分比，可能减少因为元空间不足导致的垃圾收集的频率。类似的还有-XX：Max-MetaspaceFreeRatio，用于控制最大的元空间剩余容量的百分比。</li>
</ul>
]]></content>
      <categories>
        <category>java</category>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>开篇</title>
    <url>/2023/04/23/kai_pian/</url>
    <content><![CDATA[<!-- 标签别名 -->
<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>世上只有一种英雄主义，就是认清生活的真相之后依然热爱生活。  </p>

            <i class="fa fa-quote-right"></i>
          </blockquote>]]></content>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>类文件结构</title>
    <url>/2023/04/27/lei_wen_jian_jie_gou/</url>
    <content><![CDATA[<blockquote>
<p>本文源于《深入理解Java虚拟机：JVM高级特性与最佳实践（第3版）》</p>
</blockquote>
<blockquote>
<p>计算机科学是一门通过新增中间层来解决复杂问题的学科。</p>
</blockquote>
<p>代码编译的结果从本地机器码转变为字节码，是存储格式发展的一小步，却是编程语言发展的一大步。</p>
<span id="more"></span>
<p>把Java的规范拆分成了《Java语言规范》（The Java Language Specification）及《Java虚拟机规范》 （The Java Virtual Machine Specification）两部分。这也是开发者刻意为之，希望能够让java不仅仅是作为一门程序设计语言，更寄希望于它构建一个更为强大的生态。</p>
<p>实现语言无关性的基础仍然是虚拟机和字节码存储格式。为此java通过编译称为字节码，在通过java虚拟机运行字节码，实现java语言的平台无关性。这隐含着一个条件：<strong>字节码指令所能提供的语言描述能力必然比Java语言本身更加强大</strong>。它能够做到java可以做到的，也能做到java无法做到的。这也为其他语言通过字节码实现有别于Java的语言特性提供了发挥空间。</p>
<p><img src="https://image.tool4.fun/%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/20230427015543647.png"></p>
<p>听起来，字节码很强大啊，那么我们将目光从java转向字节码，先看看字节码是什么，后续我们再看看字节码如何在java虚拟机中运行。<br>字节码是什么？我们知道他能定义数据，同时能够进行流程运转，这意味着什么呢？这意味着<strong>字节码分为两类，一类是对数据的定义，一类是对行为的描述。</strong></p>
<h2 id="Class-类文件的结构"><a href="#Class-类文件的结构" class="headerlink" title="Class 类文件的结构"></a>Class 类文件的结构</h2><h3 id="我们先来看下Class文件是什么？"><a href="#我们先来看下Class文件是什么？" class="headerlink" title="我们先来看下Class文件是什么？"></a>我们先来看下Class文件是什么？</h3><p>Class文件是一组以8个字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在文 件之中，中间没有添加任何分隔符，这使得整个Class文件中存储的内容几乎全部是程序运行的必要数据，没有空隙存在。</p>
<h3 id="既然没有分隔符，没有空隙，那么怎么去区分不同功能的字节码呢？这就需要我们了解一下Class文件的结构了。"><a href="#既然没有分隔符，没有空隙，那么怎么去区分不同功能的字节码呢？这就需要我们了解一下Class文件的结构了。" class="headerlink" title="既然没有分隔符，没有空隙，那么怎么去区分不同功能的字节码呢？这就需要我们了解一下Class文件的结构了。"></a>既然没有分隔符，没有空隙，那么怎么去区分不同功能的字节码呢？这就需要我们了解一下Class文件的结构了。</h3><p>不过在说类文件结构之前，我们先看下我们对于结构的定义是如何的。</p>
<ul>
<li>Class文件格式采用一种类似于C语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型：“<strong>无符号数</strong>”和“<strong>表</strong>”。<ul>
<li>无符号数属于基本的数据类型，以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个 字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串 值。</li>
<li>表是由多个无符号数或者其他表作为数据项构成的复合数据类型，为了便于区分，所有表的命名都习惯性地以“_info”结尾。表用于描述有层次关系的复合结构的数据，整个Class文件本质上也可以视作是一张表。</li>
<li>无论是无符号数还是表，当需要描述同一类型但数量不定的多个数据时，经常会使用一个前置的<strong>容量计数器</strong>加若干个连续的数据项的形式，这时候称这一系列连续的某一类型的数据为某一类型的“集 合”。</li>
</ul>
</li>
</ul>
<p>我们先看看每个Class文件都包含了哪些结构：</p>
<table>
<thead>
<tr>
<th>魔数</th>
</tr>
</thead>
<tbody><tr>
<td>版本号</td>
</tr>
<tr>
<td>常量池</td>
</tr>
<tr>
<td>访问标志</td>
</tr>
<tr>
<td>类索引、父类索引与接口索引</td>
</tr>
<tr>
<td>字段表集合</td>
</tr>
<tr>
<td>方法表集合</td>
</tr>
<tr>
<td>属性表集合</td>
</tr>
</tbody></table>
<p>刨除前两个，是不是发现和我们java文件很像？确实，毕竟class文件就是为了实现java。接下来一个一个看对应的结构存储了什么，以及为什么结构是这样的。</p>
<h4 id="魔数"><a href="#魔数" class="headerlink" title="魔数"></a>魔数</h4><p>每个Class文件的<strong>头4个字节</strong>被称为魔数（Magic Number），它的唯一作用是确定这个文件是否为 一个能被虚拟机接受的Class文件。很多文件格式标准中都有使用魔数来进行身份识别的习惯，Class文件的魔数取得很有“浪漫气息”，值为<strong>0xCAFEBABE</strong>。</p>
<h4 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h4><p>紧接着魔数的4个字节存储的是Class文件的版本号：<strong>第5和第6个字节是次版本号</strong>（Minor Version），<strong>第7和第8个字节是主版本号</strong>（Major Version）。</p>
<h4 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h4><p>紧接着主、次版本号之后的是常量池入口，常量池可以比喻为Class文件里的资源仓库，它是Class 文件结构中与其他项目关联最多的数据，通常也是占用Class文件空间最大的数据项目之一。常量池中每一项常量都是一个表。基本上里面的有三类数据：常量值计数值、字面量、符号引用。</p>
<ul>
<li><p><strong>常量池的入口需要放置一项u2类型的数据，代表常量池容量计数值（constant_pool_count）</strong>。这个容量计数是从1而不是0开始。这样做的目的在于，如果后面某些指向常量池的索引值的数据在特定情况下需要表达“不引用任何一个常量池项目”的含义，可以把索引值设置为0来表示</p>
</li>
<li><p><strong>字面量比较接近于Java语言层面的常量概念，如文本字符串、被声明为final的常量值等。</strong>简单理解就是，字面量所存储的数据都是静态数据，不会在Class文件加载到java虚拟机后而发生变化。</p>
</li>
<li><p><strong>符号引用</strong>则属于编译原理方面的概念</p>
<ul>
<li>主要包括下面几类常量：<ul>
<li>被模块导出或者开放的包（Package） </li>
<li>类和接口的全限定名（Fully Qualified Name） </li>
<li>字段的名称和描述符（Descriptor） </li>
<li>方法的名称和描述符 ·方法句柄和方法类型（Method Handle、Method Type、Invoke Dynamic） </li>
<li>动态调用点和动态常量（Dynamically-Computed Call Site、Dynamically-Computed Constant）</li>
</ul>
</li>
<li>虚拟机加载Class 文件的时候进行动态连接。也就是说，在Class文件中不会保存各个方法、字段最终在内存中的布局信息，这些字段、方法的符号引用不经过虚拟机在运行期转换的话是无法得到真正的内存入口地址，也就无法直接被虚拟机使用的。当虚拟机做类加载时，将会从常量池获得对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址之中。</li>
</ul>
</li>
</ul>
<p><img src="https://image.tool4.fun/%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/20230427015823368.png"></p>
<p>举例来说，对于一个CONSTANT_Class_info类型的常量，此类型的常量代表一个类或者接口的符号引用。<br><img src="https://image.tool4.fun/%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/20230427015841321.png"><br>当我们读到一个常量的tag时，就知道这个常量的类型了。这时候我们知道他的类型是CONSTANT_Class_info，那么接下来两个字节就是指向常量池中一个 CONSTANT_Utf8_info类型常量，此常量代表了这个类（或者接口）的全限定名。<br><img src="https://image.tool4.fun/%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/20230427020044820.png"><br>length值说明了这个UTF-8编码的字符串长度是多少字节，它后面紧跟着的长度为length字节的连续数据是一个使用UTF-8缩略编码表示的字符串。<br><img src="https://image.tool4.fun/%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/20230427020107536.png"><br>而CONSTANT_Class_info就是一个 符号引用类型的常量，CONSTANT_Utf8_info就是一个字面量类型的常量。这样通过例子我们就能很清楚的知道<strong>常量池中数据之间是如何关联的，以及符号引用与字面量的差异</strong>。</p>
<p><strong>Java中方法、字段名的最大长度为64K。</strong>注意，在上面的例子中，我们看到Class文件中方法、字段等都需要引用CONSTANT_Utf8_info型常量来描述名 称，所以CONSTANT_Utf8_info型常量的最大长度也就是Java中方法、字段名的最大长度。而这里的 最大长度就是length的最大值，既u2类型能表达的最大值65535。所以Java程序中如果定义了超过64KB 英文字符的变量或方法名，即使规则和全部字符都是合法的，也会无法编译。</p>
<h4 id="访问标志"><a href="#访问标志" class="headerlink" title="访问标志"></a>访问标志</h4><p><strong>在常量池结束之后，紧接着的2个字节代表访问标志（access_flags）</strong>，这个标志用于识别一些类或 者接口层次的访问信息，包括：这个Class是类还是接口；是否定义为public类型；是否定义为abstract 类型；如果是类的话，是否被声明为final；等等。access_flags中一共有16个标志位可以使用，当前只定义了其中9个。</p>
<p><img src="https://image.tool4.fun/%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/20230427020125968.png"></p>
<h4 id="类索引、父类索引与接口索引集合"><a href="#类索引、父类索引与接口索引集合" class="headerlink" title="类索引、父类索引与接口索引集合"></a>类索引、父类索引与接口索引集合</h4><p>访问标志之后就是<strong>类索引、父类索引和接口索引集合</strong>。Class文件中由这三项数据来确定该类型的继承关系。</p>
<ul>
<li>类索引（this_class）和父类索引（super_class）都是一个u2类型的数据。它们各自指向一个类型为CONSTANT_Class_info的类描述符常量</li>
<li>接口索引集合 （interfaces）是一组u2类型的数据的集合。入口的第一项u2类型的数据为接口计数器（interfaces_count），表示索引表的容量。</li>
</ul>
<h4 id="字段表集合"><a href="#字段表集合" class="headerlink" title="字段表集合"></a>字段表集合</h4><blockquote>
<p>Java语言中的“字段”（Field）包括类级变量以及实例级变量，但不包括在方法内部声明的局部变量。</p>
</blockquote>
<p>字段表集合包含容量计数器与字段表。</p>
<p>第一个u2 类型的数据为容量计数器fields_count。紧接着的就是字段表（<strong>字段表（field_info）用于描述接口或者类中声明的变量</strong>）。</p>
<p>我们想想字段一般包含哪些东西？</p>
<ul>
<li>修饰符：有字段的作用域（public、private、protected修饰 符）、是实例变量还是类变量（static修饰符）、可变性（final）、并发可见性（volatile修饰符，是否 强制从主内存读写）、可否被序列化（transient修饰符）、字段数据类型（基本类型、对象、数组）、</li>
<li>字段名称。</li>
<li>字段值。</li>
</ul>
<p>那Class文件是如何描述字段的呢？通过字段表。</p>
<p><img src="https://image.tool4.fun/%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/20230427020145135.png"></p>
<ul>
<li>access_flags：即为<strong>字段的修饰符</strong>与类中的access_flags项目是非常类似的，都是一个u2的数据类型。</li>
<li>nameIndex：即为<strong>字段的简单名称</strong>和上一节提到的类索引类似，也是一个对常量池的引用。</li>
<li>descriptor_index：<strong>字段的描述符</strong>。我们发现，修饰符可以分为类型的修饰符以及描述数据类型的修饰符。其中前者我们可以通过access_flags进行表达，而后者则需要通过字段的描述符进行表达。</li>
<li>attributes_count、attributes：<strong>属性表集合</strong>。这是用来做什么的呢？回想上文，我们是不是发现字段值还没有进行表达？没错，如果字段有字段值的话，就会被存储在属性表集合中。属性表是什么，我们后面会说，目前只要知道，属性表会有类型以及存储的数据，当属性表表达的是字段值的时候，类型为ConstantValue，而对于存储的数据就是指向常量池的一个索引，而对应的常量就是真正的属性值。</li>
</ul>
<blockquote>
<p>注：刚刚提到了描述符，除了字段外，方法也会有描述符。<strong>描述符的作用是用来描述字段的数据类型、方法的参数列表（包括数量、类型以及顺序）和返回值。</strong><br>根据描述符规则，基本数据类 型（byte、char、double、float、int、long、short、boolean）以及代表无返回值的void类型都用一个大 写字符来表示，而对象类型则用字符L加对象的全限定名来表示。<br>举例来说：</p>
<ul>
<li>一个定义为“java.lang.String[][]”类型 的二维数组将被记录成“[[Ljava&#x2F;lang&#x2F;String；”</li>
<li>方法java.lang.String toString()的描述符 为“()Ljava&#x2F;lang&#x2F;String；”</li>
</ul>
</blockquote>
<p>字段表集合中不会列出从父类或者父接口中继承而来的字段，但有可能出现原本Java代码之中不存在的字段，譬如在<strong>内部类中为了保持对外部类的访问性，编译器就会自动添加指向外部类实例的字段</strong>。另外，在Java语言中字段是无法重载的，两个字段的数据类型、修饰符不管是否相同，都必须使用不一样的名称，但是<strong>对于Class文件格式来讲，只要两个字段的描述符不是完全相同，那字段重名就是合法的</strong>。</p>
<h4 id="方法表集合"><a href="#方法表集合" class="headerlink" title="方法表集合"></a>方法表集合</h4><p>通过上面Class文件对于字段的表示形式，我们其实也能推断出其对于方法的表示形式。二者从结构上没有太多的差异，只是在具体的取值上存在差异。我们想一想，其实方法体中的实际运行的代码与字段的字段值又有什么区别呢？从实现上看，确实没有差异，方发表中通过类型为code的属性表来存储实际运行的字节码，字段表通过ConstantValue的属性表来存储实际的属性值。</p>
<p>因此这里直接贴出来方法表的结构。<br><img src="https://image.tool4.fun/%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/20230427020204558.png"><br>我们发现，与前者一模一样。因此也不多说什么了。</p>
<p><strong>在上文中我们说字段表集合会出现原先代码不存在的字段。那方法表是否也会呢？</strong><br>确实会。最常见的便是类构造器“<clinit>()”方法和实例构造器“<init>()”方法。</p>
<p><strong>上文还提到了，只要字段表的描述符不相同，Class文件就认为是不同的字段，那方法表呢？</strong><br>同理。只要方法表中的描述符不同，Class文件就认为是不相同的方法。反过来，java中认为什么样的方法是不同的方法呢？java认为需要简单名称与特征签名存在一个不同即为不同的方法。因此java中名称相同，而特征签名不同，即认为彼此重载。<br>这里简单说下特征签名：</p>
<ul>
<li><strong>Java代码的方法特征签名只包括方法名称、参数顺序及参数类型。</strong></li>
<li><strong>字节码的特征签名在java的基础上还包括方法返回值以及受查异常表</strong>。</li>
</ul>
<h4 id="属性表集合"><a href="#属性表集合" class="headerlink" title="属性表集合"></a>属性表集合</h4><p>属性表（attribute_info）在前面的讲解之中已经出现过数次，<strong>Class文件、字段表、方法表都可以携带自己的属性表集合，以描述某些场景专有的信息。</strong></p>
<p><strong>在上面我们大致了解了属性表是如何存储数据的，接下来我们看下它的基础结构：</strong><br><img src="https://image.tool4.fun/%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/20230427020225080.png"><br>为什么说是基础呢？因为不同类型的属性表存储的信息是不同的，所以其info基本上都是完全不同的。<br>我们简单看下code属性表中具体存量哪些数据吧，其他的就不细看了。<br><img src="https://image.tool4.fun/%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/20230427020245051.png"></p>
<ul>
<li>attribute_name_index是一项指向CONSTANT_Utf8_info型常量的索引，此常量值固定为“Code”，它 代表了该属性的属性名称。</li>
<li>attribute_length指示了属性值的长度，由于属性名称索引与属性长度一共为 6个字节，所以属性值的长度固定为整个属性表长度减去6个字节。</li>
<li>max_stack代表了操作数栈（Operand Stack）深度的最大值。</li>
<li>max_locals代表了局部变量表所需的存储空间。在这里，max_locals的单位是变量槽（Slot），变量 槽是虚拟机为局部变量分配内存所使用的最小单位。<ul>
<li>注意，<strong>操作数栈和局部变量表直接决定一个该方法的栈帧所耗费的内存。</strong></li>
<li>Java虚拟机中会将局部变量表中的变量槽进行重用，当代码执行超出一个局部变量的作用域时，这个局部变量所占的变量槽可以被其他局部变量所使用，Javac编译器会根据变量的作用域来分配变量槽给各个变量使用，<strong>根据同时生存的最大局部变量数量和类型计算出max_locals的大小</strong>。</li>
</ul>
</li>
<li>code_length和code用来存储Java源程序编译后生成的字节码指令。code_length代表字节码长度，code是用于存储字节码指令的一系列字节流。<ul>
<li>关于code_length，虽然它是一个u4类型的长度值，理论上最大值可以达 到2的32次幂，但是《Java虚拟机规范》中明确限制了一个方法不允许超过65535条字节码指令，即它实际只使用了u2的长度，如果超过这个限制，Javac编译器就会拒绝编译。</li>
</ul>
</li>
</ul>
<p>Code属性是Class文件中最重要的一个属性，如果把一个<strong>Java程序中的信息分为代码（Code，方法体里面的Java代码）和元数据（Metadata，包括类、字段、方法定义及其他信息）两部分</strong>，那么在整个Class文件里，Code属性用于描述代码，所有的其他数据项目都用于描述元数据。</p>
<p>注意：<strong>非静态方法最少有一个参数。</strong><br>一条Java语言里面的潜规则：在任何实例方法里面，都可以通过“this”关键字访问到此方法所属的对象。这个访问机制对Java程序的编写很重要，而它的实现非常简单，仅仅是通过在Javac编译器编译的时候把对this关键字的访问转变为对一个普通方法参数的访问，然后在虚拟机调用实例方法 时自动传入此参数而已。</p>
<h2 id="字节码指令简介"><a href="#字节码指令简介" class="headerlink" title="字节码指令简介"></a>字节码指令简介</h2><p>字节码指令很多，就像我们学习java一样，有着各类的指令，这里我们就简单的看下指令的定义以及有哪些不同类型的指令吧，不然光背的话，意义不大。还是了解含义，以后需要时查官方定义算了。毕竟我们是做java开发，而不是虚拟机开发。</p>
<p>J<strong>ava虚拟机的指令由一个字节长度的、代表着某种特定操作含义的数字（称为操作码，Opcode） 以及跟随其后的零至多个代表此操作所需的参数（称为操作数，Operand）构成</strong>。<br>字节码基本的执行模型如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    自动计算PC寄存器的值加<span class="number">1</span>; </span><br><span class="line">    根据PC寄存器指示的位置，从字节码流中取出操作码; </span><br><span class="line">    <span class="keyword">if</span> (字节码存在操作数) 从字节码流中取出操作数; </span><br><span class="line">    执行操作码所定义的操作; </span><br><span class="line">&#125; <span class="keyword">while</span> (字节码流长度 &gt; <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>在Java虚拟机的指令集中，大多数指令都包含其操作所对应的数据类型信息。i代表对int类型的数据操作，l代表long，s代表short，b代表byte，c代表char，f代表 float，d代表double，a代表reference。</p>
<p>我们简单看下有哪些类型的指令：</p>
<ul>
<li>加载和存储指令：将数据在栈帧中的局部变量表和操作数栈之间来回传输。</li>
<li>运算指令：用于对两个操作数栈上的值进行某种特定运算，并把结果重新存入到操作栈顶。</li>
<li>类型转换指令：类型转换指令可以将两种不同的数值类型相互转换，这些转换操作一般用于实现用户代码中的显 式类型转换操作，或者用来处理本节开篇所提到的字节码指令集中数据类型相关指令无法与数据类型 一一对应的问题。分为：宽化类型转换、窄化类型转换。</li>
<li>对象创建与访问指令：虽然类实例和数组都是对象，但Java虚拟机对类实例和数组的创建与操作使用了不同的字节码指令。</li>
<li>操作数栈管理指令：</li>
<li>控制转移指令</li>
<li>方法调用和返回指令</li>
<li><del>异常处理指令</del>（目前通过异常表完成异常处理）</li>
<li>同步指令：Java虚拟机可以支持方法级的同步和方法内部一段指令序列的同步，这两种同步结构都是使用管 程（Monitor，更常见的是直接将它称为“锁”）来实现的。</li>
</ul>
<p>这些指令时如何运转以及使用的，在后续说到了字节码加载到内存并运行之后，就能够了解了。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>以上介绍了类文件，包含类文件结构以及字节码指令。分别用于基础数据的定义与数据的处理。</p>
<p>回想开篇，什么是平台无关性？平台无关性如何实现？我们现在了解到的是平台无关系的基石，即底层的数据与行为支撑。</p>
<p>在有了平台无关性的基石之后，我们又能如何去往下，让数据动起来，让流程跑起来，让平台无关性得以实现？<br>不知大家发现没，本章其实一直说的是静态数据，让数据跑起来的前提就是让数据进入内存，那么接下来，我们把存储在磁盘上的Class文件加载到内存中，看看java虚拟机是如何加载类文件，又是如何处理的。</p>
]]></content>
      <categories>
        <category>java</category>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>垃圾收集器与内存分配策略</title>
    <url>/2023/04/25/la_ji_shou_ji_qi_yu_nei_cun_fen_pei_ce_lue/</url>
    <content><![CDATA[<blockquote>
<p>本文源于《深入理解Java虚拟机：JVM高级特性与最佳实践（第3版）》<br>回答以下问题：</p>
<ol>
<li>什么是内存管理？</li>
<li>如何进行内存管理？</li>
<li>如何自动进行内存管理？</li>
</ol>
</blockquote>
<span id="more"></span>

<p>垃圾收集主要是三件事情：</p>
<ol>
<li>哪些内存需要回收？</li>
<li>什么时候回收？</li>
<li>如何回收？</li>
</ol>
<h2 id="哪些内存需要回收："><a href="#哪些内存需要回收：" class="headerlink" title="哪些内存需要回收："></a>哪些内存需要回收：</h2><ul>
<li>线程隔离的数据区：程序计数器、虚拟机栈、本地方法栈3个区域随线程而生，随线程而灭。内存分配与回收在编译期可知，具备确定性，无需过多考虑回收的问题。</li>
<li>线程共享的数据区：java堆与方法区的内存具有不确定性，内存的占用是编译期无法确定的。因此这部分内存需要在运行期间进行重点管理。</li>
</ul>
<h2 id="什么时候回收这些内存："><a href="#什么时候回收这些内存：" class="headerlink" title="什么时候回收这些内存："></a>什么时候回收这些内存：</h2><p>什么样的内存需要回收，自然是用不到的内存。为此，我们需要判断什么样的内存是用不到的，这个问题放在java堆中，自然是对象什么时候无用了；而放在方法区中，则是常量以及类型什么时候后无用了。</p>
<p>因此，我们先看对象何时无用。即何时已死。</p>
<h3 id="对象已死？"><a href="#对象已死？" class="headerlink" title="对象已死？"></a>对象已死？</h3><p>我们不好让对象自己说自己是否已经死亡，所以需要从外部判断对象是否已死，这有两种算法。</p>
<ul>
<li><strong>引用计数算法</strong>：在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的<ul>
<li>优点：判断效率高。</li>
<li>缺点：存在很多例外情况，例如对象的循环引用（可以使用recycle算法进行甄别）。</li>
</ul>
</li>
<li><strong>可达性分析算法</strong>：通过 一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过 程所走过的路径称为“引用链”（Reference Chain），如果某个对象到GC Roots间没有任何引用链相连， 或者用图论的话来说就是从GC Roots到这个对象不可达时，则证明此对象是不可能再被使用的。<ul>
<li>在java中可以固定作为GC Roots的对象（处于全局性的引用以及执行上下文中）：<ul>
<li><strong>虚拟机栈</strong>（栈帧中的本地变量表）中引用的对象</li>
<li><strong>方法区</strong>中类静态属性引用的对象</li>
<li><strong>方法区</strong>中常量引用的对象</li>
<li><strong>本地方法栈</strong>中JNI（即通常所说的Native方法）引用的对象</li>
<li>Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如 NullPointExcepiton、OutOfMemoryError）等，还有系统类加载器。</li>
<li>所有被同步锁（synchronized关键字）持有的对象。</li>
<li>反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等</li>
</ul>
</li>
<li>临时性作为GC Roots的对象：<ul>
<li>其他分区的对象对当前待收集分区的对象存在引用。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>但上面的两种算法只能判断引用是否存在，当存在其他场景，如缓存：即使存在引用，我依旧想将其回收。就无法进行处理。因此，java中有四种引用的类型。强引用（Strongly Re-ference）、软引用（Soft Reference）、弱引用（Weak Reference）和虚引用（Phantom Reference）</p>
<ul>
<li>强引用是最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值。只要存在就不会回收。</li>
<li>软引用是用来描述一些还有用，但非必须的对象。在系统将要发生内 存溢出异常前，会把这些对象列进回收范围之中进行第二次回收。</li>
<li>弱引用也是用来描述那些非必须对象，当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。</li>
<li>虚引用也称为“幽灵引用”或者“幻影引用”，不影响垃圾收集器的行为，为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。</li>
</ul>
<p>当然，java给了已经死了的对象一个机会，让其可以复活一次。<br>要真正宣告一个对象死亡，至少要经历两次标记过程：如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记，随后进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。如果这个对象被判定为确有必要执行finalize()方法，那么该对象将会被放置在一个名为F-Queue的 队列之中，并在稍后由一条由虚拟机自动建立的、低调度优先级的Finalizer线程去执行它们的finalize() 方法。但该方法只会执行一次。不过在Java18中已经被标记为废弃了。</p>
<h3 id="常量与类型已经无用？"><a href="#常量与类型已经无用？" class="headerlink" title="常量与类型已经无用？"></a>常量与类型已经无用？</h3><p>说完了堆，该说方法区了。方法区中需要被回收的有两类：废弃的常量和不再使用的类型。</p>
<p>回收废弃常量与回收 Java堆中的对象非常类似。即判断是否有引用，若无则视为已死，可以回收。</p>
<p>要判定一个类型是否属于“不再被使用的类”的条件就 比较苛刻了。需要同时满足下面三个条件：</p>
<ul>
<li>该类所有的实例都已经被回收。</li>
<li>加载该类的类加载器已经被回收。基本上只有自定义类加载器可以满足这个条件。</li>
<li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>
</ul>
<p>注意第二个条件，使用字节码框架时常常自定义类加载器，这些都需要java虚拟机具备类型卸载的能力，不然会把方法区内存挤爆。</p>
<h2 id="如何回收内存："><a href="#如何回收内存：" class="headerlink" title="如何回收内存："></a>如何回收内存：</h2><p>（以下均基于可达性分析算法找到需要回收的内存）</p>
<p>回收内存有一个经验法则（先辈得出，我们暂且不论如何推导出来的），分代收集理论：将内存分为两块区域分别进行回收。而这基于一下三个假说。</p>
<ol>
<li>弱分代假说（Weak Generational Hypothesis）：绝大多数对象都是朝生夕灭的。</li>
<li>强分代假说（Strong Generational Hypothesis）：熬过越多次垃圾收集过程的对象就越难以消亡。</li>
<li>跨代引用假说（Intergenerational Reference Hypothesis）：跨代引用相对于同代引用来说仅占极少数。</li>
</ol>
<p>这个理论是如何指引当前真正的内存回收的呢？</p>
<ul>
<li>对于前2个假说，我们在不同的区域回收内存时，使用不同的方式回收，以满足不同区域内存的特性。</li>
<li>对于第3个假说，我们通过记忆集，用空间（存储记忆集）换时间（避免扫描完全另外一个内存区域），由于跨带引用占少数，因此空间换时间是划算的。</li>
</ul>
<p>按照分代收集理论，我们将内存分为两个区域，那我们如何对两个区域进行内存收集呢？这就不得不提到进行内存收集时的三个基础算法了。<br>内存收集算法：</p>
<ul>
<li><strong>标记-清除算法</strong>：首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象，也可以反过来，标记存活的对象，统一回收所有未被标记的对象。标记过程即为找已死亡对象的过程。<ul>
<li>存在问题：<ul>
<li>执行效率不稳定。在内存区域较大时，需要花费大量的时间标记与清理。</li>
<li>内存碎片化。清理后会产生大量不连续的内存碎片，致使大对象无法分配，这就让内存需要更为复杂的分配策略，而内存访问是很频繁的，复杂的策略，会降低整体的吞吐量。</li>
</ul>
</li>
</ul>
</li>
<li><strong>标记-复制算法</strong>：将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。面对大量可回收对象时效率高。<ul>
<li>存在问题：<ul>
<li>当大量对象处于存活状态时，执行的效率低。</li>
<li>可用内存被缩小为一半，浪费较多。</li>
</ul>
</li>
<li>优化的半区复制分带策略：<strong>Appel式回收</strong>的具体做法是把新生代分为一块较大的Eden空间和两块较小的 Survivor空间，每次分配内存只使用Eden和其中一块Survivor。HotSpot虚拟机默认Eden和Survivor的大小比例是8∶1，这样的复制算法，内存消耗仅为10%。如果复制时发现超过10%，则通过<strong>分配担保机制</strong>，分配到老年代。</li>
</ul>
</li>
<li><strong>标记-整理算法</strong>：针对老年代对象的存亡特征而诞生。其中的标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存。<ul>
<li>存在的问题：<ul>
<li>移动存活对象时，必须暂停用户应用程序，这使得内存收集时，延迟猛增。但相对于不移动对象带来的吞吐量下降，只能说各有千秋。</li>
</ul>
</li>
<li>优化的整理与清除算法：让虚拟机平时多数时间都采用标记-清除算法，暂时容忍内存碎片的存在，直到内存空间的碎片化程度已经大到影响对象分配时，再采用标记-整理算法收集一次，以获得规整的内存空间。这就是CMS的策略。</li>
</ul>
</li>
</ul>
<p>我们在上面三节分别说了：what、when、how。即哪些内存需要回收，何时回收以及如何回收。但这些都是抽象层面的，即仅仅是一个思路，那么hotspot虚拟机具体又是怎么去做的呢？并且对于部分存在问题的地方又是如何优化的呢？<br>所以接下来，我们看看hotspot虚拟机内部是如何判断内存需要回收以及如何回收的。</p>
<h2 id="HotSpot-虚拟机中，什么时候回收内存"><a href="#HotSpot-虚拟机中，什么时候回收内存" class="headerlink" title="HotSpot 虚拟机中，什么时候回收内存"></a>HotSpot 虚拟机中，什么时候回收内存</h2><p>如何判断内存需要回收，我们在上面提到通过两者算法判断对象的有效性，那么接下来我们看看hotspot是如何通过可达性分析算法找到有效对象以及对可达性分析算法的优化。<br>首先，可达性分析算法需要找到GC Roots。上面也提到了GC Roots有哪些，那么我们要如何找到呢？</p>
<p>对于固定的GC Roots，即在全局性的引用（例如常量或类静态属性）与执行上下文（例如 栈帧中的本地变量表）中的对象。</p>
<ul>
<li>这些是我们在类加载期间可以明确的，那么我们只要在这个过程记录下来这些引用。并在对象收集过程中使用即可。存放这些引用的结构称为<strong>OopMap</strong>。</li>
<li>这里出现个问题，我们不能把所有类加载时均记录下来，这样OopMap的数据量太大了，因此我们只在某些地方才进行记录，我们将其称为<strong>安全点</strong>。这些地方需要满足程序长时间执行的特征，因为这样，对象的引用在这个长时间内不会发生变化。一般长时间执行的特征就是指令序列的复用，例如方法调用、循环跳转、异常跳转等都属于指令序列复用，所以只有具有这些功能的指令才会产生安全点。<ul>
<li>垃圾收集器依赖OopMap，OopMap依赖安全点，那么发生内存收集时，必须让用户线程处于安全点才可以。如何让其处于安全点就有两种方法：抢先式中断 （Preemptive Suspension）和主动式中断（Voluntary Suspension）。<ul>
<li>抢占式中断需要系统主动中断用户线程。</li>
<li>主动式中断则需要线程自身运行到安全点时时去判断当前是否处于内存回收中，如果是则挂起等待。</li>
</ul>
</li>
<li>hotspot使用后者，使用内存保护陷阱的方式，通过一条汇编指令test，判断具体内存页是否可读，不可读则产生一个自陷异常信号，然后在预先注册的异常处理器中挂起线程实现等待。</li>
</ul>
</li>
<li>并发场景下线程无法响应虚拟机的中断请求，不能再走到安全的地方去中断挂起自己。这时候需要定义一段<strong>安全区域</strong>，安全区域是指能够确保在某一段代码片段之中，引用关系不会发生变化。当处于安全区域时，垃圾收集器可以安全的进行回收</li>
</ul>
<p>其次，对于跨带引用所带来的问题，我们上文提到需要通过<strong>记忆集</strong>去记录从非收集区域指向收集区域的指针集合。那么hotsopt中的记忆集是什么样子的呢？</p>
<p>首先要明确，记忆集是一个抽象概念，它是一个抽象的集合。那记忆集具体有哪些呢？</p>
<ul>
<li>字长精度的记忆集。</li>
<li>对象精度的记忆集。</li>
<li>卡精度的记忆集。又被称为<strong>卡表</strong>。一块区域内的对象有跨带指针。</li>
</ul>
<p>这三者从上而下，粒度越来越粗，实现也越来越简单。<strong>HotSpot虚拟机通过一个字节数组实现卡表</strong>。</p>
<p><strong>字节数组CARD_TABLE</strong>的每一个元素都对应着其标识的内存区域中一块特定大小的内存块，这个内存块被称作“<strong>卡页</strong>”（Card Page）。卡表与卡页的对应见下图。<br>一个卡页的内存中通常包含不止一个对象，只要卡页内有一个（或更多）对象的字段存在着跨代指针，那就将对应卡表的数组元素的值标识为1，称为这个元素变脏（Dirty），没有则标识为0。在垃圾收集发生时，只要筛选出卡表中变脏的元素，就能轻易得出哪些卡页内存块中包含跨代指针，把它们加入GC Roots中一并扫描。</p>
<p><img src="https://image.tool4.fun/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/20230425113402977.png"></p>
<p>我们已经解决了如何使用记忆集来缩减GC Roots扫描范围的问题，但还没有解决卡表元素如何维护的问题，例如它们何时变脏、谁来把它们变脏等。</p>
<ul>
<li>卡表元素何时变脏的答案是很明确的——有其他分代区域中对象引用了本区域对象时，其对应的卡表元素就应该变脏。</li>
<li>如何变脏，则是通过<strong>写屏障</strong>。通过AOP的形式。以写后屏障的方式，进行处理。<ul>
<li>写屏障存在了两个问题<ul>
<li><strong>写屏障的开销</strong>：这相对于Minor GC时扫描整个老年代的代价相比还是低得多。</li>
<li><strong>伪共享问题</strong>：伪共享是处 理并发底层细节时一种经常需要考虑的问题，现代中央处理器的缓存系统中是以缓存行（Cache Line） 为单位存储的，当多线程修改互相独立的变量时，如果这些变量恰好共享同一个缓存行，就会彼此影 响（写回、无效化或者同步）而导致性能降低，这就是伪共享问题。可以先检查卡表标记，只有当该卡表元素未被标记过时才将其标记为变脏。</li>
</ul>
</li>
<li>在JDK 7之后，HotSpot虚拟机增加了一个新的参数-XX：+UseCondCardMark，用来决定是否开启卡表更新的条件判断。开启会增加一次额外判断的开销，但能够避免伪共享问题。</li>
</ul>
</li>
</ul>
<p>到此我们找到了所有GC Roots，那么接下来，我们要沿着他们找到所有可达的对象。这一步好做，向下遍历就可以。但有个问题，找GC Roots时我们已经STW了，这部分耗时较短，我们还能接受，那向下遍历肯定很耗时，我们不可能继续STW，但不STW，就会存在问题。本来可达的对象，由于在遍历过程中，被用户线程变更了其引用，导致被内存收集线程错误的认为不可达了，这要怎么解决呢？为此我们需要引入三色标记，模拟一下出现这种情况的原因。注意看下图。</p>
<ul>
<li>白色：表示对象尚未被垃圾收集器访问过。显然在可达性分析刚刚开始的阶段，所有的对象都是 白色的，若在分析结束的阶段，仍然是白色的对象，即代表不可达。</li>
<li>黑色：表示对象已经被垃圾收集器访问过，且这个对象的所有引用都已经扫描过。黑色的对象代 表已经扫描过，它是安全存活的，如果有其他对象引用指向了黑色对象，无须重新扫描一遍。黑色对 象不可能直接（不经过灰色对象）指向某个白色对象。</li>
<li>灰色：表示对象已经被垃圾收集器访问过，但这个对象上至少存在一个引用还没有被扫描过。</li>
</ul>
<p><img src="https://image.tool4.fun/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/20230425113517504.png"></p>
<p>我们也能发现，其实不可达的原因是两个：</p>
<ul>
<li>赋值器插入了一条或多条从黑色对象到白色对象的新引用；</li>
<li>赋值器删除了全部从灰色对象到该白色对象的直接或间接引用。</li>
</ul>
<p>这两个原因导致了该对象无法被遍历到。那么我们只需破坏这两个条件的任意一个即可。这就产生了两种解决方案：增量更新（Incremental Update）和原始快照（Snapshot At The Beginning， SATB）。</p>
<ul>
<li><strong>增量更新</strong>要破坏的是第一个条件，当黑色对象插入新的指向白色对象的引用关系时，就将这个新插入的引用记录下来，等并发扫描结束之后，再将这些记录过的引用关系中的黑色对象为根，重新扫描一次。这可以简化理解为，<strong>黑色对象一旦新插入了指向白色对象的引用之后，它就变回灰色对象</strong> 了。</li>
<li><strong>原始快照</strong>要破坏的是第二个条件，当灰色对象要删除指向白色对象的引用关系时，就将这个要删除的引用记录下来，在并发扫描结束之后，再将这些记录过的引用关系中的灰色对象为根，重新扫描 一次。这也可以简化理解为，<strong>无论引用关系删除与否，都会按照刚刚开始扫描那一刻的对象图快照</strong>来进行搜索。</li>
</ul>
<p>注意着二者均通过写屏障实现。CMS是基于增量更新 来做并发标记的，G1、Shenandoah则是用原始快照来实现。</p>
<p>到此，我们的hotspot虚拟机已经找到了所有待收集的对象，接下来，就要真正的开始收集对象了。</p>
<h2 id="HotSpot-虚拟机中，到底谁在收集垃圾呢？–垃圾收集器"><a href="#HotSpot-虚拟机中，到底谁在收集垃圾呢？–垃圾收集器" class="headerlink" title="HotSpot 虚拟机中，到底谁在收集垃圾呢？–垃圾收集器"></a>HotSpot 虚拟机中，到底谁在收集垃圾呢？–垃圾收集器</h2><p>经常说，通过垃圾收集器收集对象，其实没错，我们上面说的都是各种方法论（不论是可达性分析算法还是垃圾收集算法等等），真正进行内存管理的，是在具体场景为了一定目的进行对象收集的垃圾收集器，正是他们践行了一个个方法论。</p>
<p><img src="https://image.tool4.fun/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/20230425113535196.png"></p>
<p>下面有些名词需要提前解释一下：<br><strong>并行与并发</strong>：</p>
<ul>
<li><strong>并行</strong>描述的是多条垃圾收集器线程之间的关系，说明同一时间有多条这样的线 程在协同工作，通常默认此时用户线程是处于等待状态。</li>
<li><strong>并发</strong>描述的是垃圾收集器线程与用户线程之间的关系，说明同一时间垃圾收集器线程与用户线程都在运行。由于用户线程并未被冻结，所以程序仍然能响应服务请求，但由于垃圾收集器线程占用了一部分系统资源，此时应用程序的处理的吞吐量将受到一定影响。</li>
</ul>
<p><strong>吞吐量与停顿时间</strong>：</p>
<ul>
<li><strong>吞吐量</strong>：处理器用于运行用户代码的时间与处理器总消耗时间的比值。</li>
<li><strong>停顿时间</strong>：或者说延迟，是用户代码被暂停的时间，这影响用户的使用体验。</li>
<li>垃圾收集停顿时间缩短是以牺牲吞吐量和新生代空间为代价换取的： 系统把新生代调得小一些，收集300MB新生代肯定比收集500MB快，但这也直接导致垃圾收集发生得更频繁，原来10秒收集一次、每次停顿100毫秒，现在变成5秒收集一次、每次停顿70毫秒。停顿时间 的确在下降，但吞吐量也降下来了，</li>
</ul>
<p>Serial 收集器：一个单线程工作的收集器，但它的“单线程”的意义并不仅仅是说明它只会使用一个处理器或一条收集线程去完成垃圾收集工作，更重要的是强调在它进行垃圾收集时，必须暂停其他所有工作线程，直到它收集结束。</p>
<ul>
<li>用于新生代，采用复制算法。</li>
<li>优点：内存消耗小；单核处理器或处理器核心数较少的环境来说收集效率高。</li>
<li>是HotSpot虚拟机运行在客户端模式下的默认新生代收集器。</li>
</ul>
<p>ParNew收集器：实质上是Serial收集器的多线程并行版本。</p>
<ul>
<li>用于新生代，采用复制算法。并行收集。</li>
<li>优点：并发收集，多核场景优于Serial；可以与CMS搭配使用。</li>
</ul>
<p>Parallel Scavenge收集器：目标是达到一个可控制的吞吐量（Throughput）。</p>
<ul>
<li>用于新生代，采用复制算法。并行收集。</li>
<li>内部自带 PS MarkSweep收集器，与Serial Old几乎相同，用于对应的老年代收集。</li>
<li>Parallel Scavenge收集器提供了两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间的-XX：MaxGCPauseMillis参数以及直接设置吞吐量大小的-XX：GCTimeRatio参数。</li>
<li>-XX：+UseAdaptiveSizePolicy 激活时，虚拟机会动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。</li>
<li>注意：无法和CMS搭配使用，因为架构不同，这也导致了他只能搭配自带的单线程收集器或者后面推出的Parallel Old收集器使用。</li>
</ul>
<p>Serial Old收集器：是Serial收集器的老年代版本，它同样是一个单线程收集器。</p>
<ul>
<li>用于老年代，采用标记整理算法。</li>
<li>客户端模式下，与Serial搭配使用。</li>
<li>服务端模式下<ul>
<li>一种是在JDK 5以及之前的版本中与Parallel Scavenge收集器搭配使用（由于PS MarkSweep收集器与Serial Old的实现几乎是一样的，我们将之视为同一个）</li>
<li>另外一种就是作为CMS 收集器发生失败时的后备预案，在并发收集发生Concurrent Mode Failure时使用。这种情况下CMS退化为full gc，通过Serial Old实现老年代的空间整理。</li>
</ul>
</li>
</ul>
<p>Parallel Old收集器：Parallel Scavenge收集器的老年代版本，支持多线程并发收集。</p>
<ul>
<li>用于老年代，采用标记整理算法。</li>
<li>服务端搭配Parallel Scavenge使用。</li>
<li>在注重吞吐量或者处理器资源较为稀缺的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器</li>
</ul>
<p>CMS 收集器：一种以获取最短回收停顿时间为目标的收集器。</p>
<ul>
<li>用于老年代，采用标记清除算法。</li>
<li>与之前的收集器不同，会通过并发的形式，减少用户线程的停顿，因此步骤也相对于前面的收集器更为复杂。共有四个步骤。<ul>
<li><strong>初始标记</strong>：<strong>（STW）</strong>记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快。</li>
<li><strong>并发标记</strong>：从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行。</li>
<li><strong>重新标记</strong>：<strong>（STW）</strong>通过增量更新，修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录。</li>
<li><strong>并发清除</strong>：最后是并发清除阶段，清理删除掉标记阶段判断的已经死亡的 对象，由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的</li>
</ul>
</li>
<li>有三个明显的问题：<ul>
<li><strong>CMS收集器对处理器资源非常敏感</strong>：即使并发执行，也是抢占了用户线程的CPU资源，降低了用户程序的执行速度。即使提供了增量式并发收集器，也是让收集时间变长，速度变慢的时间变长了，意义不大。</li>
<li><strong>无法处理浮动垃圾</strong>：浮动垃圾即在并发标记与并发清理阶段，用户线程产生的垃圾对象。这部分需要六道下次垃圾收集过程进行收集，这意味着要预留足够内存空间提供给用户线程使用，因此CMS收集器不能像其他收集器那样等待到老年代几乎完全被填满了再进行收集，必须预留一部分空间供并发收集时的程序运作使用。<strong>如果major gc 过程中出现老年代对象分配失败，就降级为full gc，垃圾收集器也退化为Serial Old，对老年代空间进行整理</strong>。</li>
<li>收集结束时会有大量空间碎片产生：<ul>
<li>-XX：+UseCMS-CompactAtFullCollection。设置CMS收集器是否在完成垃圾收集后要进行一次内存碎片整理。默认开启。</li>
<li>-XX：CMSFullGCsBeforeCompaction。设置CMS收集器在完成若干次垃圾收集后在启动一次内存碎片整理，默认为0，即每次都整理。</li>
</ul>
</li>
</ul>
</li>
<li>注意CMS有三种GC行为：<ul>
<li>major gc   标记清除</li>
<li>full gc 标记清除</li>
<li>full gc 标记整理</li>
</ul>
</li>
<li>CMS GC要决定是否在full GC时做压缩，会依赖几个条件。这个可以看看R大的详细说明。<a href="https://hllvm-group.iteye.com/group/topic/28854">https://hllvm-group.iteye.com/group/topic/28854</a></li>
</ul>
<p>Garbage First（简称G1）收集器：设计者们希望做出一款能够建立起“停顿时间模型”（Pause Prediction Model）的收集器。</p>
<ul>
<li><strong>进行Mixed GC</strong>。</li>
<li><strong>基于Region的堆内存布局</strong>：把连续的Java堆划分为多个大小相等的独立区域（Region），分别作为Eden空间、Survivor空间，或者老年代空间。还有一类特殊的Humongous区域，专门用来存储大对象，G1将其视为老年代。将Region作 为单次回收的最小单元，避免 在整个Java堆中进行全区域的垃圾收集，通过设立<strong>优先级列表</strong>，每次根据用户设定允许的收集停顿时间，优先处理回收价值收益最大的那些Region</li>
<li>存在的一些细节解决方案：<ul>
<li><strong>跨Region引用对象如何解决</strong>？<ul>
<li>每个Region都维护有自己的记忆集，这些记忆集会记录下别的Region 指向自己的指针，并标记这些指针分别在哪些卡页的范围之内，是一种<strong>双向卡表</strong>，由于region数量多，卡表的内存占用很大，大约相当于Java堆容量10%至20%的额外内存。</li>
</ul>
</li>
<li><strong>在并发标记阶段如何保证收集线程与用户线程互不干扰地运行？</strong><ul>
<li>历史对象：通过原始快照（SATB）算法来避免用户线程改变对象引用关系。</li>
<li>新对象：每一个Region设 计了两个名为TAMS（Top at Mark Start）的指针，将中间的部分用于并发回收过程中的新对象分配。</li>
</ul>
</li>
<li><strong>怎样建立起可靠的停顿预测模型？</strong><ul>
<li>G1收集器的停顿 预测模型是以衰减均值（Decaying Average）为理论基础来实现的。记录各个可测量的步骤花费的成本，并分析得 出平均值、标准偏差、置信度等统计信息。</li>
</ul>
</li>
</ul>
</li>
<li>运作过程<ul>
<li><strong>初始标记</strong>：（STW）标记一下GC Roots能直接关联到的对象，并且修改TAMS 指针的值</li>
<li><strong>并发标记</strong>：从GC Root开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象</li>
<li><strong>最终标记</strong>：（STW）处理并发阶段结束后仍遗留下来的最后那少量的SATB记录。</li>
<li><strong>筛选回收</strong>：（STW）负责更新Region的统计数据，对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧 Region的全部空间。</li>
</ul>
</li>
<li>从G1开始，最先进的垃圾收集器的设计导向都不约而同地变为追求能够应付应用的内存分配速率（Allocation Rate），而不追求一次把整个Java堆全部清理干净。</li>
<li>G1 与 CMS相比，存在的劣势：<ul>
<li>内存：G1的卡表实现更为复杂，占用的内存空间大。CMS的卡表只有唯一一份，而且只需要处理老年代到新生代的引用。</li>
<li>执行负载：CMS用写后屏障来更新维护卡表；而G1除了使用写后屏障来进行 同样的（由于G1的卡表结构复杂，其实是更烦琐的）卡表维护操作外，为了实现原始快照搜索 （SATB）算法，还需要使用写前屏障来跟踪并发时的指针变化情况。</li>
</ul>
</li>
</ul>
<p>衡量垃圾收集器的三项最重要的指标是：内存占用（Footprint）、吞吐量（Throughput）和延迟（Latency），三者共同构成了一个“不可能三角  ”。三者总体的表现会随技术进步而越来越好，但是 要在这三个方面同时具有卓越表现的“完美”收集器是极其困难甚至是不可能的，一款优秀的收集器通 常最多可以同时达成其中的两项。</p>
<p><img src="https://image.tool4.fun/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/20230425113555330.png"></p>
<p>Shenandoah收集器：一种能在任何堆内存大小下都可以把垃圾收集的停顿时间限制在十毫秒以内的垃圾收集器。</p>
<ul>
<li>相较于G1的不同<ul>
<li>支持并发的整理算法</li>
<li>Shenandoah（目前）是默认不使用分代收集的</li>
<li>用“连接矩阵”（Connection Matrix）的全局数据结构来记录跨Region的引用关系</li>
</ul>
</li>
<li>运作过程的重要并发阶段：<ul>
<li>并发标记</li>
<li><strong>并发回收：通过读屏障和被称为“Brooks Pointers”的转发指针来解决</strong></li>
<li>并发引用更新：按照内存物理地址的顺序，线性地搜索出引用类型，把旧值改为新值即可。</li>
</ul>
</li>
<li><strong>Brooks Pointers</strong>：在原有对象布局结构的最前面统一增加一个新的引用字段<ul>
<li>带来一次额外的转向开销</li>
<li>当对象拥有了一份新的副本时，只需要修改一处指针的值，即旧对象上转发指针的引用位置，使其指向新对象，便可将所有对该对象的访问转 发到新的副本上。</li>
<li>并发场景通过CAS保证访问对象的正确性，避免修改对象字段时，修改到了旧对象上。</li>
<li>需要覆盖全部对象访问操作，Shenandoah不得不同时设置读、写屏障去拦截。而数量庞大的读屏障带来的将是相对写屏障较大的性能开销。后续内存屏障只拦截对象中数据类型为引用类型的读写操作，而不去管原生数据类型等其他非引用字段的读写。</li>
</ul>
</li>
</ul>
<p>ZGC收集器：一款基于Region内存布局的，（暂时） 不设分代的，使用了读屏障、染色指针和内存多重映射等技术来实现可并发的标记-整理算法的，以低延迟为首要目标的一款垃圾收集器。</p>
<ul>
<li>不支持分代，垃圾收集时扫描所有内存区域。</li>
<li><strong>基于动态Region的堆内存布局：</strong>动态创建和销毁，以及动态的区域容量大小。<ul>
<li>小型Region（Small Region）：容量固定为2MB，用于放置小于256KB的小对象。</li>
<li>中型Region（Medium Region）：容量固定为32MB，用于放置大于等于256KB但小于4MB的对 象。</li>
<li>大型Region（Large Region）：容量不固定，可以动态变化，但必须为2MB的整数倍，用于放置 4MB或以上的大对象。每个大型Region中只会存放一个大对象，这也预示着虽然名字叫作“大型 Region”，但它的实际容量完全有可能小于中型Region，最小容量可低至4MB。大型Region在ZGC的实现中是不会被重分配。</li>
</ul>
</li>
<li>并发整理的实现-<strong>染色指针：</strong><ul>
<li>染色指针是一种直接将少量额外的信息存储在指针上的技术。</li>
<li>尽管Linux下64位指针的高18位不能用来寻址，但剩余的46位指针所能支持的64TB内存在今天仍然能够充分满足大型服务器的需要。鉴于此，ZGC的染色指针技术继续盯上了这剩下的46位指针宽度，将其<strong>高4位提取出来存储四个标志信息</strong>。</li>
<li>Java虚拟机作为一个普普通通的进程， 这样随意重新定义内存中某些指针的其中几位，操作系统是否支持？处理器是否支持？<ul>
<li>Linux&#x2F;x86-64平台上的ZGC使用了<strong>多重映射（Multi-Mapping）</strong>将多个不同的虚拟内存地址映射到同一 个物理内存地址上，这是一种多对一映射，意味着ZGC在虚拟内存中看到的地址空间要比实际的堆内 存容量来得更大。把染色指针中的标志位看作是地址的分段符，那只要将这些不同的地址段都映射到同一个物理内存空间，经过多重映射转换后，就可以使用染色指针正常进行寻址了</li>
</ul>
</li>
<li>优点：<ul>
<li>染色指针可以使得一旦某个Region的存活对象被移走之后，这个Region立即就能够被释放和重用 掉，而不必等待整个堆中所有指向该Region的引用都被修正后才能清理。</li>
<li>大幅减少在垃圾收集过程中内存屏障的使用数量。</li>
</ul>
</li>
<li>劣势：直接导致<strong>ZGC能够管理的内存不可以超过4TB</strong>（2的42次幂）</li>
</ul>
</li>
<li>运作过程：<ul>
<li><strong>并发标记</strong>：ZGC 的标记是在指针上而不是在对象上进行的，标记阶段会更新染色指针中的Marked 0、Marked 1标志位。其他的话，与G1、Shenandoah基本相同。</li>
<li><strong>并发预备重分配</strong>：ZGC每次回收都会扫描所有的Region，用范围更大的扫描成本换取省去G1中记忆集的 维护成本。根据特定的查询条件统计得出 本次收集过程要清理哪些Region，将这些Region组成重分配集（Relocation Set）。</li>
<li><strong>并发重分配</strong>：这个过程要把重分配集中的存活对象复制到新的Region上，并为重分配集中的每个Region维护一个<strong>转发表（Forward Table）</strong>，记录从旧对象到新对象的转向关系。<ul>
<li>得益于染色指针的支持，ZGC收集器能仅从引用上就明 确得知一个对象是否处于重分配集之中，如果用户线程此时并发访问了位于重分配集中的对象，这次 访问将会被预置的内存屏障所截获，然后立即根据Region上的转发表记录将访问转发到新复制的对象 上，并同时修正更新该引用的值，使其直接指向新对象，ZGC将这种行为称为<strong>指针的“自愈”（SelfHealing）能力</strong>。</li>
<li>这样做的好处是只有第一次访问旧对象会陷入转发，也就是只慢一次。</li>
</ul>
</li>
<li><strong>并发重映射</strong>：修正整个堆中指向重分配集中旧对象的所有引用，这一点从目标角度看是与Shenandoah并发引用更新阶段一样的。但由于前面提到的自愈能力，ZGC很巧妙地把并发重映射 阶段要做的工作，合并到了下一次垃圾收集循环中的并发标记阶段里去完成。当所以指针都被修正后，原有的对象关系转发表就可以释放掉了。</li>
</ul>
</li>
<li>存在的问题：<ul>
<li>ZGC的这种不分代收集的选择也限制了它能承受的对象分配速率不会太高。有分代收集理论我们知道，大部分对象朝生夕灭，而ZGC却统一回收，即使收集过程停顿很短，但整个收集的过程很长，会出现浮动垃圾，这就让ZGC必须留着足够大的空间供新对象分配。</li>
</ul>
</li>
<li>支持“NUMA-Aware”的内存分配：<ul>
<li>每个处理器核心所在的裸晶（DIE）都有 属于自己内存管理器所管理的内存，如果要访问被其他处理器核心管理的内存，就必须通过InterConnect通道来完成，这要比访问处理器的本地内存慢得多。在NUMA架构下，ZGC收集器会优先尝 试在请求线程当前所处的处理器的本地内存上分配对象，以保证高效内存访问</li>
<li>之前仅有Parallel Scavenge支持。</li>
</ul>
</li>
</ul>
<h3 id="HotSpot-虚拟机如何分配对象内存"><a href="#HotSpot-虚拟机如何分配对象内存" class="headerlink" title="HotSpot 虚拟机如何分配对象内存"></a>HotSpot 虚拟机如何分配对象内存</h3><p>上面介绍了内存回收的问题，也基本上一直围绕着内存回收的一系列细节进行说明。但我们的内存管理只有回收吗？并不是。</p>
<blockquote>
<p>Java技术体系的自动内存管理，最根本的目标是自动化地解决两个问题：<strong>自动给对象分配内存以 及自动回收分配给对象的内存</strong>。</p>
</blockquote>
<p>在上一章我们也提到了对象的内存布局以及对象的创建过程，其中提到了对象的分配内存空间，如何分配内存空间取决于内存是否规整，而这个又受到垃圾收集器的算法的影响。我们在上面已经介绍完了各个垃圾收集器，接下来是时候看看如何具体的为对象分配内存空间了。</p>
<p>在分代收集理论以及基于分代的收集器中，我们得知：</p>
<ul>
<li><strong>对象优先在Eden区分配。</strong>当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC。又由Appel式回收可知，Minor GC 后我们期望的存活对象最大占用空间为一个Survivor区的容量。如果对象无法放入，则通过分配担保机制提前转移到老年代。</li>
<li><strong>大对象直接进入老年代。</strong>对象确实是优先在Eden区分配，但如果对象太大了，那最好直接分配在老年代。HotSpot虚拟机提供了-XX：PretenureSizeThreshold 参数，指定大于该设置值的对象直接在老年代分配，这样做的目的就是避免在Eden区及两个Survivor区之间来回复制，产生大量的内存复制操作。但参数只对Serial和ParNew两款新生代收集器有效。</li>
<li><strong>长期存活的对象将进入老年代。</strong>老年代的初衷本就是存放较长时间存活的对象。对象通常在Eden区里诞生，如果经过第一次 Minor GC后仍然存活，并且能被Survivor容纳的话，该对象会被移动到Survivor空间中，并且将其对象年龄设为1岁。对象在Survivor区中每熬过一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15，即第16次gc时），就会被晋升到老年代中。对象晋升老年代的年龄阈值，可以通过参数-XX： MaxTenuringThreshold设置。</li>
<li><strong>动态对象年龄判定。</strong>刚刚提到长期存活的对象进入老年代，但如果年龄设置的过大导致大量对象无法晋升或者，又或者好不容易晋升后，一会就被清理了，这样明显导致年轻代与老年代的分配不合理，老年代在这张场景下没有起到任何作用。如之前店铺能力系统的缓存GC频繁问题，其问题就在于1分钟的缓存对象，在55秒时进入老年代，解决方案是缩短或者延迟缓存时间，要么不进老年代，要么进老年代多用点时间。如果在Survivor空间中小于或等于某个年龄（假设为3）所有对象大小的总和大于 Survivor空间的-XX:TargetSurvivorRatio（50%），会将MaxTenuringThreshold 动态调整为3，并在下次GC中，将年龄大于3的对象就晋升老年代。</li>
<li><strong>空间分配担保。</strong>在发生Minor GC之前，虚拟机必须先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那这一次Minor GC可以确保是安全的。如果不成立，则虚拟机会先查看XX：HandlePromotionFailure参数的设置值是否允许担保失败（Handle Promotion Failure）；如果允许，那会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次Minor GC，尽管这次Minor GC是有风险的；如果小于，或者-XX： HandlePromotionFailure设置不允许冒险，那这时就要改为进行一次Full GC。<ul>
<li>在老年代连续最大可用空间不大于新生代所有对象总空间的前提下：差别在于开启担保，一次minor gc后会可能还会进行full gc。不开启则直接进行full gc。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">uint <span class="title function_">ageTable::compute_tenuring_threshold</span><span class="params">(<span class="type">size_t</span> survivor_capacity)</span> &#123;</span><br><span class="line">    <span class="comment">//survivor_capacity是survivor空间的大小</span></span><br><span class="line">    <span class="comment">//desired_survivor_size就是动态年龄判断是否对象进入老年代的阈值</span></span><br><span class="line">    <span class="comment">//TargetSurvivorRatio：默认50</span></span><br><span class="line">    <span class="type">size_t</span> desired_survivor_size = (<span class="type">size_t</span>)((((<span class="type">double</span>) survivor_capacity)*TargetSurvivorRatio)/<span class="number">100</span>);</span><br><span class="line">    <span class="type">size_t</span> total = <span class="number">0</span>;</span><br><span class="line">    uint age = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (age &lt; table_size) &#123;</span><br><span class="line">        <span class="comment">//sizes数组是每个年龄段对象大小</span></span><br><span class="line">        <span class="comment">//total就是年龄从小到大的对象占据的空间累加和</span></span><br><span class="line">        total += sizes[age];</span><br><span class="line">        <span class="comment">//如果累加和大于阈值，就直接跳出循环，假设磁盘的age等于3吧</span></span><br><span class="line">        <span class="keyword">if</span> (total &gt; desired_survivor_size) <span class="keyword">break</span>;</span><br><span class="line">        age++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//MaxTenuringThreshold上限是15，现在age是3，那么result就是等于3</span></span><br><span class="line">    uint result = age &lt; MaxTenuringThreshold ? age : MaxTenuringThreshold;</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p><img src="https://image.tool4.fun/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/20230425113620935.png"></p>
<p>常见的GC问题：<a href="https://tech.meituan.com/2020/11/12/java-9-cms-gc.html">https://tech.meituan.com/2020/11/12/java-9-cms-gc.html</a></p>
]]></content>
      <categories>
        <category>java</category>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>java</tag>
      </tags>
  </entry>
</search>
