---
title: 类文件结构
date: 2023-04-27 01:51:37
tags:
- 技术
- java
categories:
- java
- jvm
---
> 本文源于《深入理解Java虚拟机：JVM高级特性与最佳实践（第3版）》


> 计算机科学是一门通过新增中间层来解决复杂问题的学科。

代码编译的结果从本地机器码转变为字节码，是存储格式发展的一小步，却是编程语言发展的一大步。

<!-- more -->
把Java的规范拆分成了《Java语言规范》（The Java Language Specification）及《Java虚拟机规范》 （The Java Virtual Machine Specification）两部分。这也是开发者刻意为之，希望能够让java不仅仅是作为一门程序设计语言，更寄希望于它构建一个更为强大的生态。

实现语言无关性的基础仍然是虚拟机和字节码存储格式。为此java通过编译称为字节码，在通过java虚拟机运行字节码，实现java语言的平台无关性。这隐含着一个条件：**字节码指令所能提供的语言描述能力必然比Java语言本身更加强大**。它能够做到java可以做到的，也能做到java无法做到的。这也为其他语言通过字节码实现有别于Java的语言特性提供了发挥空间。

![](https://image.tool4.fun/类文件结构/20230427015543647.png)

听起来，字节码很强大啊，那么我们将目光从java转向字节码，先看看字节码是什么，后续我们再看看字节码如何在java虚拟机中运行。
字节码是什么？我们知道他能定义数据，同时能够进行流程运转，这意味着什么呢？这意味着**字节码分为两类，一类是对数据的定义，一类是对行为的描述。**

## Class 类文件的结构

### 我们先来看下Class文件是什么？

Class文件是一组以8个字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在文 件之中，中间没有添加任何分隔符，这使得整个Class文件中存储的内容几乎全部是程序运行的必要数据，没有空隙存在。

### 既然没有分隔符，没有空隙，那么怎么去区分不同功能的字节码呢？这就需要我们了解一下Class文件的结构了。

不过在说类文件结构之前，我们先看下我们对于结构的定义是如何的。

- Class文件格式采用一种类似于C语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型：“**无符号数**”和“**表**”。
   - 无符号数属于基本的数据类型，以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个 字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串 值。
   - 表是由多个无符号数或者其他表作为数据项构成的复合数据类型，为了便于区分，所有表的命名都习惯性地以“_info”结尾。表用于描述有层次关系的复合结构的数据，整个Class文件本质上也可以视作是一张表。
   - 无论是无符号数还是表，当需要描述同一类型但数量不定的多个数据时，经常会使用一个前置的**容量计数器**加若干个连续的数据项的形式，这时候称这一系列连续的某一类型的数据为某一类型的“集 合”。

我们先看看每个Class文件都包含了哪些结构：

| 魔数 |
| --- |
| 版本号 |
| 常量池 |
| 访问标志 |
| 类索引、父类索引与接口索引 |
| 字段表集合 |
| 方法表集合 |
| 属性表集合 |

刨除前两个，是不是发现和我们java文件很像？确实，毕竟class文件就是为了实现java。接下来一个一个看对应的结构存储了什么，以及为什么结构是这样的。

#### 魔数
每个Class文件的**头4个字节**被称为魔数（Magic Number），它的唯一作用是确定这个文件是否为 一个能被虚拟机接受的Class文件。很多文件格式标准中都有使用魔数来进行身份识别的习惯，Class文件的魔数取得很有“浪漫气息”，值为**0xCAFEBABE**。

#### 版本号
紧接着魔数的4个字节存储的是Class文件的版本号：**第5和第6个字节是次版本号**（Minor Version），**第7和第8个字节是主版本号**（Major Version）。

#### 常量池
紧接着主、次版本号之后的是常量池入口，常量池可以比喻为Class文件里的资源仓库，它是Class 文件结构中与其他项目关联最多的数据，通常也是占用Class文件空间最大的数据项目之一。常量池中每一项常量都是一个表。基本上里面的有三类数据：常量值计数值、字面量、符号引用。

- **常量池的入口需要放置一项u2类型的数据，代表常量池容量计数值（constant_pool_count）**。这个容量计数是从1而不是0开始。这样做的目的在于，如果后面某些指向常量池的索引值的数据在特定情况下需要表达“不引用任何一个常量池项目”的含义，可以把索引值设置为0来表示

- **字面量比较接近于Java语言层面的常量概念，如文本字符串、被声明为final的常量值等。**简单理解就是，字面量所存储的数据都是静态数据，不会在Class文件加载到java虚拟机后而发生变化。




- **符号引用**则属于编译原理方面的概念
   - 主要包括下面几类常量：
      - 被模块导出或者开放的包（Package） 
      - 类和接口的全限定名（Fully Qualified Name） 
      - 字段的名称和描述符（Descriptor） 
      - 方法的名称和描述符 ·方法句柄和方法类型（Method Handle、Method Type、Invoke Dynamic） 
      - 动态调用点和动态常量（Dynamically-Computed Call Site、Dynamically-Computed Constant）
   - 虚拟机加载Class 文件的时候进行动态连接。也就是说，在Class文件中不会保存各个方法、字段最终在内存中的布局信息，这些字段、方法的符号引用不经过虚拟机在运行期转换的话是无法得到真正的内存入口地址，也就无法直接被虚拟机使用的。当虚拟机做类加载时，将会从常量池获得对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址之中。

![](https://image.tool4.fun/类文件结构/20230427015823368.png)

举例来说，对于一个CONSTANT_Class_info类型的常量，此类型的常量代表一个类或者接口的符号引用。
![](https://image.tool4.fun/类文件结构/20230427015841321.png)
当我们读到一个常量的tag时，就知道这个常量的类型了。这时候我们知道他的类型是CONSTANT_Class_info，那么接下来两个字节就是指向常量池中一个 CONSTANT_Utf8_info类型常量，此常量代表了这个类（或者接口）的全限定名。
![](https://image.tool4.fun/类文件结构/20230427020044820.png)
length值说明了这个UTF-8编码的字符串长度是多少字节，它后面紧跟着的长度为length字节的连续数据是一个使用UTF-8缩略编码表示的字符串。
![](https://image.tool4.fun/类文件结构/20230427020107536.png)
而CONSTANT_Class_info就是一个 符号引用类型的常量，CONSTANT_Utf8_info就是一个字面量类型的常量。这样通过例子我们就能很清楚的知道**常量池中数据之间是如何关联的，以及符号引用与字面量的差异**。

**Java中方法、字段名的最大长度为64K。**注意，在上面的例子中，我们看到Class文件中方法、字段等都需要引用CONSTANT_Utf8_info型常量来描述名 称，所以CONSTANT_Utf8_info型常量的最大长度也就是Java中方法、字段名的最大长度。而这里的 最大长度就是length的最大值，既u2类型能表达的最大值65535。所以Java程序中如果定义了超过64KB 英文字符的变量或方法名，即使规则和全部字符都是合法的，也会无法编译。


#### 访问标志
**在常量池结束之后，紧接着的2个字节代表访问标志（access_flags）**，这个标志用于识别一些类或 者接口层次的访问信息，包括：这个Class是类还是接口；是否定义为public类型；是否定义为abstract 类型；如果是类的话，是否被声明为final；等等。access_flags中一共有16个标志位可以使用，当前只定义了其中9个。

![](https://image.tool4.fun/类文件结构/20230427020125968.png)

#### 类索引、父类索引与接口索引集合

访问标志之后就是**类索引、父类索引和接口索引集合**。Class文件中由这三项数据来确定该类型的继承关系。

- 类索引（this_class）和父类索引（super_class）都是一个u2类型的数据。它们各自指向一个类型为CONSTANT_Class_info的类描述符常量
- 接口索引集合 （interfaces）是一组u2类型的数据的集合。入口的第一项u2类型的数据为接口计数器（interfaces_count），表示索引表的容量。

#### 字段表集合
> Java语言中的“字段”（Field）包括类级变量以及实例级变量，但不包括在方法内部声明的局部变量。


字段表集合包含容量计数器与字段表。

第一个u2 类型的数据为容量计数器fields_count。紧接着的就是字段表（**字段表（field_info）用于描述接口或者类中声明的变量**）。



我们想想字段一般包含哪些东西？

- 修饰符：有字段的作用域（public、private、protected修饰 符）、是实例变量还是类变量（static修饰符）、可变性（final）、并发可见性（volatile修饰符，是否 强制从主内存读写）、可否被序列化（transient修饰符）、字段数据类型（基本类型、对象、数组）、
- 字段名称。
- 字段值。

那Class文件是如何描述字段的呢？通过字段表。

![](https://image.tool4.fun/类文件结构/20230427020145135.png)
- access_flags：即为**字段的修饰符**与类中的access_flags项目是非常类似的，都是一个u2的数据类型。
- nameIndex：即为**字段的简单名称**和上一节提到的类索引类似，也是一个对常量池的引用。
- descriptor_index：**字段的描述符**。我们发现，修饰符可以分为类型的修饰符以及描述数据类型的修饰符。其中前者我们可以通过access_flags进行表达，而后者则需要通过字段的描述符进行表达。
- attributes_count、attributes：**属性表集合**。这是用来做什么的呢？回想上文，我们是不是发现字段值还没有进行表达？没错，如果字段有字段值的话，就会被存储在属性表集合中。属性表是什么，我们后面会说，目前只要知道，属性表会有类型以及存储的数据，当属性表表达的是字段值的时候，类型为ConstantValue，而对于存储的数据就是指向常量池的一个索引，而对应的常量就是真正的属性值。

> 注：刚刚提到了描述符，除了字段外，方法也会有描述符。**描述符的作用是用来描述字段的数据类型、方法的参数列表（包括数量、类型以及顺序）和返回值。**
> 根据描述符规则，基本数据类 型（byte、char、double、float、int、long、short、boolean）以及代表无返回值的void类型都用一个大 写字符来表示，而对象类型则用字符L加对象的全限定名来表示。
> 举例来说：
> - 一个定义为“java.lang.String[][]”类型 的二维数组将被记录成“[[Ljava/lang/String；”
> - 方法java.lang.String toString()的描述符 为“()Ljava/lang/String；”


字段表集合中不会列出从父类或者父接口中继承而来的字段，但有可能出现原本Java代码之中不存在的字段，譬如在**内部类中为了保持对外部类的访问性，编译器就会自动添加指向外部类实例的字段**。另外，在Java语言中字段是无法重载的，两个字段的数据类型、修饰符不管是否相同，都必须使用不一样的名称，但是**对于Class文件格式来讲，只要两个字段的描述符不是完全相同，那字段重名就是合法的**。

#### 方法表集合
通过上面Class文件对于字段的表示形式，我们其实也能推断出其对于方法的表示形式。二者从结构上没有太多的差异，只是在具体的取值上存在差异。我们想一想，其实方法体中的实际运行的代码与字段的字段值又有什么区别呢？从实现上看，确实没有差异，方发表中通过类型为code的属性表来存储实际运行的字节码，字段表通过ConstantValue的属性表来存储实际的属性值。

因此这里直接贴出来方法表的结构。
![](https://image.tool4.fun/类文件结构/20230427020204558.png)
我们发现，与前者一模一样。因此也不多说什么了。

**在上文中我们说字段表集合会出现原先代码不存在的字段。那方法表是否也会呢？**
确实会。最常见的便是类构造器“<clinit>()”方法和实例构造器“<init>()”方法。

**上文还提到了，只要字段表的描述符不相同，Class文件就认为是不同的字段，那方法表呢？**
同理。只要方法表中的描述符不同，Class文件就认为是不相同的方法。反过来，java中认为什么样的方法是不同的方法呢？java认为需要简单名称与特征签名存在一个不同即为不同的方法。因此java中名称相同，而特征签名不同，即认为彼此重载。
这里简单说下特征签名：

- **Java代码的方法特征签名只包括方法名称、参数顺序及参数类型。**
- **字节码的特征签名在java的基础上还包括方法返回值以及受查异常表**。

#### 属性表集合

属性表（attribute_info）在前面的讲解之中已经出现过数次，**Class文件、字段表、方法表都可以携带自己的属性表集合，以描述某些场景专有的信息。**

**在上面我们大致了解了属性表是如何存储数据的，接下来我们看下它的基础结构：**
![](https://image.tool4.fun/类文件结构/20230427020225080.png)
为什么说是基础呢？因为不同类型的属性表存储的信息是不同的，所以其info基本上都是完全不同的。
我们简单看下code属性表中具体存量哪些数据吧，其他的就不细看了。
![](https://image.tool4.fun/类文件结构/20230427020245051.png)

- attribute_name_index是一项指向CONSTANT_Utf8_info型常量的索引，此常量值固定为“Code”，它 代表了该属性的属性名称。
- attribute_length指示了属性值的长度，由于属性名称索引与属性长度一共为 6个字节，所以属性值的长度固定为整个属性表长度减去6个字节。
- max_stack代表了操作数栈（Operand Stack）深度的最大值。
- max_locals代表了局部变量表所需的存储空间。在这里，max_locals的单位是变量槽（Slot），变量 槽是虚拟机为局部变量分配内存所使用的最小单位。
   - 注意，**操作数栈和局部变量表直接决定一个该方法的栈帧所耗费的内存。**
   - Java虚拟机中会将局部变量表中的变量槽进行重用，当代码执行超出一个局部变量的作用域时，这个局部变量所占的变量槽可以被其他局部变量所使用，Javac编译器会根据变量的作用域来分配变量槽给各个变量使用，**根据同时生存的最大局部变量数量和类型计算出max_locals的大小**。
- code_length和code用来存储Java源程序编译后生成的字节码指令。code_length代表字节码长度，code是用于存储字节码指令的一系列字节流。
   - 关于code_length，虽然它是一个u4类型的长度值，理论上最大值可以达 到2的32次幂，但是《Java虚拟机规范》中明确限制了一个方法不允许超过65535条字节码指令，即它实际只使用了u2的长度，如果超过这个限制，Javac编译器就会拒绝编译。

Code属性是Class文件中最重要的一个属性，如果把一个**Java程序中的信息分为代码（Code，方法体里面的Java代码）和元数据（Metadata，包括类、字段、方法定义及其他信息）两部分**，那么在整个Class文件里，Code属性用于描述代码，所有的其他数据项目都用于描述元数据。

注意：**非静态方法最少有一个参数。**
一条Java语言里面的潜规则：在任何实例方法里面，都可以通过“this”关键字访问到此方法所属的对象。这个访问机制对Java程序的编写很重要，而它的实现非常简单，仅仅是通过在Javac编译器编译的时候把对this关键字的访问转变为对一个普通方法参数的访问，然后在虚拟机调用实例方法 时自动传入此参数而已。

## 字节码指令简介
字节码指令很多，就像我们学习java一样，有着各类的指令，这里我们就简单的看下指令的定义以及有哪些不同类型的指令吧，不然光背的话，意义不大。还是了解含义，以后需要时查官方定义算了。毕竟我们是做java开发，而不是虚拟机开发。

J**ava虚拟机的指令由一个字节长度的、代表着某种特定操作含义的数字（称为操作码，Opcode） 以及跟随其后的零至多个代表此操作所需的参数（称为操作数，Operand）构成**。
字节码基本的执行模型如下：
```c
do {
    自动计算PC寄存器的值加1; 
    根据PC寄存器指示的位置，从字节码流中取出操作码; 
    if (字节码存在操作数) 从字节码流中取出操作数; 
    执行操作码所定义的操作; 
} while (字节码流长度 > 0);
```

在Java虚拟机的指令集中，大多数指令都包含其操作所对应的数据类型信息。i代表对int类型的数据操作，l代表long，s代表short，b代表byte，c代表char，f代表 float，d代表double，a代表reference。

我们简单看下有哪些类型的指令：

- 加载和存储指令：将数据在栈帧中的局部变量表和操作数栈之间来回传输。
- 运算指令：用于对两个操作数栈上的值进行某种特定运算，并把结果重新存入到操作栈顶。
- 类型转换指令：类型转换指令可以将两种不同的数值类型相互转换，这些转换操作一般用于实现用户代码中的显 式类型转换操作，或者用来处理本节开篇所提到的字节码指令集中数据类型相关指令无法与数据类型 一一对应的问题。分为：宽化类型转换、窄化类型转换。
- 对象创建与访问指令：虽然类实例和数组都是对象，但Java虚拟机对类实例和数组的创建与操作使用了不同的字节码指令。
- 操作数栈管理指令：
- 控制转移指令
- 方法调用和返回指令
- ~~异常处理指令~~（目前通过异常表完成异常处理）
- 同步指令：Java虚拟机可以支持方法级的同步和方法内部一段指令序列的同步，这两种同步结构都是使用管 程（Monitor，更常见的是直接将它称为“锁”）来实现的。

这些指令时如何运转以及使用的，在后续说到了字节码加载到内存并运行之后，就能够了解了。
## 小结
以上介绍了类文件，包含类文件结构以及字节码指令。分别用于基础数据的定义与数据的处理。

回想开篇，什么是平台无关性？平台无关性如何实现？我们现在了解到的是平台无关系的基石，即底层的数据与行为支撑。

在有了平台无关性的基石之后，我们又能如何去往下，让数据动起来，让流程跑起来，让平台无关性得以实现？
不知大家发现没，本章其实一直说的是静态数据，让数据跑起来的前提就是让数据进入内存，那么接下来，我们把存储在磁盘上的Class文件加载到内存中，看看java虚拟机是如何加载类文件，又是如何处理的。
