---
title: 垃圾收集器与内存分配策略
date: 2023-04-25 23:25:32
tags:
- 技术
- java
categories:
- java
- jvm
---
> 本文源于《深入理解Java虚拟机：JVM高级特性与最佳实践（第3版）》
> 回答以下问题：
> 1. 什么是内存管理？
> 2. 如何进行内存管理？
> 2. 如何自动进行内存管理？

<!-- more -->

垃圾收集主要是三件事情：

1. 哪些内存需要回收？
2. 什么时候回收？
3. 如何回收？

## 哪些内存需要回收：

- 线程隔离的数据区：程序计数器、虚拟机栈、本地方法栈3个区域随线程而生，随线程而灭。内存分配与回收在编译期可知，具备确定性，无需过多考虑回收的问题。
- 线程共享的数据区：java堆与方法区的内存具有不确定性，内存的占用是编译期无法确定的。因此这部分内存需要在运行期间进行重点管理。

## 什么时候回收这些内存：
什么样的内存需要回收，自然是用不到的内存。为此，我们需要判断什么样的内存是用不到的，这个问题放在java堆中，自然是对象什么时候无用了；而放在方法区中，则是常量以及类型什么时候后无用了。

因此，我们先看对象何时无用。即何时已死。
### 对象已死？
我们不好让对象自己说自己是否已经死亡，所以需要从外部判断对象是否已死，这有两种算法。

- **引用计数算法**：在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的
   - 优点：判断效率高。
   - 缺点：存在很多例外情况，例如对象的循环引用（可以使用recycle算法进行甄别）。
- **可达性分析算法**：通过 一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过 程所走过的路径称为“引用链”（Reference Chain），如果某个对象到GC Roots间没有任何引用链相连， 或者用图论的话来说就是从GC Roots到这个对象不可达时，则证明此对象是不可能再被使用的。
   - 在java中可以固定作为GC Roots的对象（处于全局性的引用以及执行上下文中）：
      - **虚拟机栈**（栈帧中的本地变量表）中引用的对象
      - **方法区**中类静态属性引用的对象
      - **方法区**中常量引用的对象
      - **本地方法栈**中JNI（即通常所说的Native方法）引用的对象
      - Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如 NullPointExcepiton、OutOfMemoryError）等，还有系统类加载器。
      - 所有被同步锁（synchronized关键字）持有的对象。
      - 反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等
   - 临时性作为GC Roots的对象：
      - 其他分区的对象对当前待收集分区的对象存在引用。

但上面的两种算法只能判断引用是否存在，当存在其他场景，如缓存：即使存在引用，我依旧想将其回收。就无法进行处理。因此，java中有四种引用的类型。强引用（Strongly Re-ference）、软引用（Soft Reference）、弱引用（Weak Reference）和虚引用（Phantom Reference）

- 强引用是最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值。只要存在就不会回收。
- 软引用是用来描述一些还有用，但非必须的对象。在系统将要发生内 存溢出异常前，会把这些对象列进回收范围之中进行第二次回收。
- 弱引用也是用来描述那些非必须对象，当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。
- 虚引用也称为“幽灵引用”或者“幻影引用”，不影响垃圾收集器的行为，为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。

当然，java给了已经死了的对象一个机会，让其可以复活一次。
要真正宣告一个对象死亡，至少要经历两次标记过程：如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记，随后进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。如果这个对象被判定为确有必要执行finalize()方法，那么该对象将会被放置在一个名为F-Queue的 队列之中，并在稍后由一条由虚拟机自动建立的、低调度优先级的Finalizer线程去执行它们的finalize() 方法。但该方法只会执行一次。不过在Java18中已经被标记为废弃了。

### 常量与类型已经无用？
说完了堆，该说方法区了。方法区中需要被回收的有两类：废弃的常量和不再使用的类型。

回收废弃常量与回收 Java堆中的对象非常类似。即判断是否有引用，若无则视为已死，可以回收。

要判定一个类型是否属于“不再被使用的类”的条件就 比较苛刻了。需要同时满足下面三个条件：

- 该类所有的实例都已经被回收。
- 加载该类的类加载器已经被回收。基本上只有自定义类加载器可以满足这个条件。
- 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

注意第二个条件，使用字节码框架时常常自定义类加载器，这些都需要java虚拟机具备类型卸载的能力，不然会把方法区内存挤爆。


## 如何回收内存：
（以下均基于可达性分析算法找到需要回收的内存）

回收内存有一个经验法则（先辈得出，我们暂且不论如何推导出来的），分代收集理论：将内存分为两块区域分别进行回收。而这基于一下三个假说。

1. 弱分代假说（Weak Generational Hypothesis）：绝大多数对象都是朝生夕灭的。
2. 强分代假说（Strong Generational Hypothesis）：熬过越多次垃圾收集过程的对象就越难以消亡。
3. 跨代引用假说（Intergenerational Reference Hypothesis）：跨代引用相对于同代引用来说仅占极少数。

这个理论是如何指引当前真正的内存回收的呢？

- 对于前2个假说，我们在不同的区域回收内存时，使用不同的方式回收，以满足不同区域内存的特性。
- 对于第3个假说，我们通过记忆集，用空间（存储记忆集）换时间（避免扫描完全另外一个内存区域），由于跨带引用占少数，因此空间换时间是划算的。

按照分代收集理论，我们将内存分为两个区域，那我们如何对两个区域进行内存收集呢？这就不得不提到进行内存收集时的三个基础算法了。
内存收集算法：

- **标记-清除算法**：首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象，也可以反过来，标记存活的对象，统一回收所有未被标记的对象。标记过程即为找已死亡对象的过程。
   - 存在问题：
      - 执行效率不稳定。在内存区域较大时，需要花费大量的时间标记与清理。
      - 内存碎片化。清理后会产生大量不连续的内存碎片，致使大对象无法分配，这就让内存需要更为复杂的分配策略，而内存访问是很频繁的，复杂的策略，会降低整体的吞吐量。
- **标记-复制算法**：将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。面对大量可回收对象时效率高。
   - 存在问题：
      - 当大量对象处于存活状态时，执行的效率低。
      - 可用内存被缩小为一半，浪费较多。
   - 优化的半区复制分带策略：**Appel式回收**的具体做法是把新生代分为一块较大的Eden空间和两块较小的 Survivor空间，每次分配内存只使用Eden和其中一块Survivor。HotSpot虚拟机默认Eden和Survivor的大小比例是8∶1，这样的复制算法，内存消耗仅为10%。如果复制时发现超过10%，则通过**分配担保机制**，分配到老年代。
- **标记-整理算法**：针对老年代对象的存亡特征而诞生。其中的标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存。
   - 存在的问题：
      - 移动存活对象时，必须暂停用户应用程序，这使得内存收集时，延迟猛增。但相对于不移动对象带来的吞吐量下降，只能说各有千秋。
   - 优化的整理与清除算法：让虚拟机平时多数时间都采用标记-清除算法，暂时容忍内存碎片的存在，直到内存空间的碎片化程度已经大到影响对象分配时，再采用标记-整理算法收集一次，以获得规整的内存空间。这就是CMS的策略。

我们在上面三节分别说了：what、when、how。即哪些内存需要回收，何时回收以及如何回收。但这些都是抽象层面的，即仅仅是一个思路，那么hotspot虚拟机具体又是怎么去做的呢？并且对于部分存在问题的地方又是如何优化的呢？
所以接下来，我们看看hotspot虚拟机内部是如何判断内存需要回收以及如何回收的。

## HotSpot 虚拟机中，什么时候回收内存

如何判断内存需要回收，我们在上面提到通过两者算法判断对象的有效性，那么接下来我们看看hotspot是如何通过可达性分析算法找到有效对象以及对可达性分析算法的优化。
首先，可达性分析算法需要找到GC Roots。上面也提到了GC Roots有哪些，那么我们要如何找到呢？

对于固定的GC Roots，即在全局性的引用（例如常量或类静态属性）与执行上下文（例如 栈帧中的本地变量表）中的对象。

- 这些是我们在类加载期间可以明确的，那么我们只要在这个过程记录下来这些引用。并在对象收集过程中使用即可。存放这些引用的结构称为**OopMap**。
- 这里出现个问题，我们不能把所有类加载时均记录下来，这样OopMap的数据量太大了，因此我们只在某些地方才进行记录，我们将其称为**安全点**。这些地方需要满足程序长时间执行的特征，因为这样，对象的引用在这个长时间内不会发生变化。一般长时间执行的特征就是指令序列的复用，例如方法调用、循环跳转、异常跳转等都属于指令序列复用，所以只有具有这些功能的指令才会产生安全点。
   - 垃圾收集器依赖OopMap，OopMap依赖安全点，那么发生内存收集时，必须让用户线程处于安全点才可以。如何让其处于安全点就有两种方法：抢先式中断 （Preemptive Suspension）和主动式中断（Voluntary Suspension）。
      - 抢占式中断需要系统主动中断用户线程。
      - 主动式中断则需要线程自身运行到安全点时时去判断当前是否处于内存回收中，如果是则挂起等待。
   - hotspot使用后者，使用内存保护陷阱的方式，通过一条汇编指令test，判断具体内存页是否可读，不可读则产生一个自陷异常信号，然后在预先注册的异常处理器中挂起线程实现等待。
- 并发场景下线程无法响应虚拟机的中断请求，不能再走到安全的地方去中断挂起自己。这时候需要定义一段**安全区域**，安全区域是指能够确保在某一段代码片段之中，引用关系不会发生变化。当处于安全区域时，垃圾收集器可以安全的进行回收

其次，对于跨带引用所带来的问题，我们上文提到需要通过**记忆集**去记录从非收集区域指向收集区域的指针集合。那么hotsopt中的记忆集是什么样子的呢？

首先要明确，记忆集是一个抽象概念，它是一个抽象的集合。那记忆集具体有哪些呢？

- 字长精度的记忆集。
- 对象精度的记忆集。
- 卡精度的记忆集。又被称为**卡表**。一块区域内的对象有跨带指针。

这三者从上而下，粒度越来越粗，实现也越来越简单。**HotSpot虚拟机通过一个字节数组实现卡表**。

**字节数组CARD_TABLE**的每一个元素都对应着其标识的内存区域中一块特定大小的内存块，这个内存块被称作“**卡页**”（Card Page）。卡表与卡页的对应见下图。
一个卡页的内存中通常包含不止一个对象，只要卡页内有一个（或更多）对象的字段存在着跨代指针，那就将对应卡表的数组元素的值标识为1，称为这个元素变脏（Dirty），没有则标识为0。在垃圾收集发生时，只要筛选出卡表中变脏的元素，就能轻易得出哪些卡页内存块中包含跨代指针，把它们加入GC Roots中一并扫描。

![](https://image.tool4.fun/垃圾收集器与内存分配策略/20230425113402977.png)

我们已经解决了如何使用记忆集来缩减GC Roots扫描范围的问题，但还没有解决卡表元素如何维护的问题，例如它们何时变脏、谁来把它们变脏等。

- 卡表元素何时变脏的答案是很明确的——有其他分代区域中对象引用了本区域对象时，其对应的卡表元素就应该变脏。
- 如何变脏，则是通过**写屏障**。通过AOP的形式。以写后屏障的方式，进行处理。
   - 写屏障存在了两个问题
      - **写屏障的开销**：这相对于Minor GC时扫描整个老年代的代价相比还是低得多。
      - **伪共享问题**：伪共享是处 理并发底层细节时一种经常需要考虑的问题，现代中央处理器的缓存系统中是以缓存行（Cache Line） 为单位存储的，当多线程修改互相独立的变量时，如果这些变量恰好共享同一个缓存行，就会彼此影 响（写回、无效化或者同步）而导致性能降低，这就是伪共享问题。可以先检查卡表标记，只有当该卡表元素未被标记过时才将其标记为变脏。
   - 在JDK 7之后，HotSpot虚拟机增加了一个新的参数-XX：+UseCondCardMark，用来决定是否开启卡表更新的条件判断。开启会增加一次额外判断的开销，但能够避免伪共享问题。

到此我们找到了所有GC Roots，那么接下来，我们要沿着他们找到所有可达的对象。这一步好做，向下遍历就可以。但有个问题，找GC Roots时我们已经STW了，这部分耗时较短，我们还能接受，那向下遍历肯定很耗时，我们不可能继续STW，但不STW，就会存在问题。本来可达的对象，由于在遍历过程中，被用户线程变更了其引用，导致被内存收集线程错误的认为不可达了，这要怎么解决呢？为此我们需要引入三色标记，模拟一下出现这种情况的原因。注意看下图。

- 白色：表示对象尚未被垃圾收集器访问过。显然在可达性分析刚刚开始的阶段，所有的对象都是 白色的，若在分析结束的阶段，仍然是白色的对象，即代表不可达。
- 黑色：表示对象已经被垃圾收集器访问过，且这个对象的所有引用都已经扫描过。黑色的对象代 表已经扫描过，它是安全存活的，如果有其他对象引用指向了黑色对象，无须重新扫描一遍。黑色对 象不可能直接（不经过灰色对象）指向某个白色对象。
- 灰色：表示对象已经被垃圾收集器访问过，但这个对象上至少存在一个引用还没有被扫描过。

![](https://image.tool4.fun/垃圾收集器与内存分配策略/20230425113517504.png)

我们也能发现，其实不可达的原因是两个：

- 赋值器插入了一条或多条从黑色对象到白色对象的新引用；
- 赋值器删除了全部从灰色对象到该白色对象的直接或间接引用。

这两个原因导致了该对象无法被遍历到。那么我们只需破坏这两个条件的任意一个即可。这就产生了两种解决方案：增量更新（Incremental Update）和原始快照（Snapshot At The Beginning， SATB）。

- **增量更新**要破坏的是第一个条件，当黑色对象插入新的指向白色对象的引用关系时，就将这个新插入的引用记录下来，等并发扫描结束之后，再将这些记录过的引用关系中的黑色对象为根，重新扫描一次。这可以简化理解为，**黑色对象一旦新插入了指向白色对象的引用之后，它就变回灰色对象** 了。
- **原始快照**要破坏的是第二个条件，当灰色对象要删除指向白色对象的引用关系时，就将这个要删除的引用记录下来，在并发扫描结束之后，再将这些记录过的引用关系中的灰色对象为根，重新扫描 一次。这也可以简化理解为，**无论引用关系删除与否，都会按照刚刚开始扫描那一刻的对象图快照**来进行搜索。

注意着二者均通过写屏障实现。CMS是基于增量更新 来做并发标记的，G1、Shenandoah则是用原始快照来实现。

到此，我们的hotspot虚拟机已经找到了所有待收集的对象，接下来，就要真正的开始收集对象了。

## HotSpot 虚拟机中，到底谁在收集垃圾呢？--垃圾收集器

经常说，通过垃圾收集器收集对象，其实没错，我们上面说的都是各种方法论（不论是可达性分析算法还是垃圾收集算法等等），真正进行内存管理的，是在具体场景为了一定目的进行对象收集的垃圾收集器，正是他们践行了一个个方法论。

![](https://image.tool4.fun/垃圾收集器与内存分配策略/20230425113535196.png)

下面有些名词需要提前解释一下：
**并行与并发**：

- **并行**描述的是多条垃圾收集器线程之间的关系，说明同一时间有多条这样的线 程在协同工作，通常默认此时用户线程是处于等待状态。
- **并发**描述的是垃圾收集器线程与用户线程之间的关系，说明同一时间垃圾收集器线程与用户线程都在运行。由于用户线程并未被冻结，所以程序仍然能响应服务请求，但由于垃圾收集器线程占用了一部分系统资源，此时应用程序的处理的吞吐量将受到一定影响。

**吞吐量与停顿时间**：

- **吞吐量**：处理器用于运行用户代码的时间与处理器总消耗时间的比值。
- **停顿时间**：或者说延迟，是用户代码被暂停的时间，这影响用户的使用体验。
- 垃圾收集停顿时间缩短是以牺牲吞吐量和新生代空间为代价换取的： 系统把新生代调得小一些，收集300MB新生代肯定比收集500MB快，但这也直接导致垃圾收集发生得更频繁，原来10秒收集一次、每次停顿100毫秒，现在变成5秒收集一次、每次停顿70毫秒。停顿时间 的确在下降，但吞吐量也降下来了，


Serial 收集器：一个单线程工作的收集器，但它的“单线程”的意义并不仅仅是说明它只会使用一个处理器或一条收集线程去完成垃圾收集工作，更重要的是强调在它进行垃圾收集时，必须暂停其他所有工作线程，直到它收集结束。

- 用于新生代，采用复制算法。
- 优点：内存消耗小；单核处理器或处理器核心数较少的环境来说收集效率高。
- 是HotSpot虚拟机运行在客户端模式下的默认新生代收集器。

ParNew收集器：实质上是Serial收集器的多线程并行版本。

- 用于新生代，采用复制算法。并行收集。
- 优点：并发收集，多核场景优于Serial；可以与CMS搭配使用。

Parallel Scavenge收集器：目标是达到一个可控制的吞吐量（Throughput）。

- 用于新生代，采用复制算法。并行收集。
- 内部自带 PS MarkSweep收集器，与Serial Old几乎相同，用于对应的老年代收集。
- Parallel Scavenge收集器提供了两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间的-XX：MaxGCPauseMillis参数以及直接设置吞吐量大小的-XX：GCTimeRatio参数。
- -XX：+UseAdaptiveSizePolicy 激活时，虚拟机会动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。
- 注意：无法和CMS搭配使用，因为架构不同，这也导致了他只能搭配自带的单线程收集器或者后面推出的Parallel Old收集器使用。

Serial Old收集器：是Serial收集器的老年代版本，它同样是一个单线程收集器。

- 用于老年代，采用标记整理算法。
- 客户端模式下，与Serial搭配使用。
- 服务端模式下
   - 一种是在JDK 5以及之前的版本中与Parallel Scavenge收集器搭配使用（由于PS MarkSweep收集器与Serial Old的实现几乎是一样的，我们将之视为同一个）
   - 另外一种就是作为CMS 收集器发生失败时的后备预案，在并发收集发生Concurrent Mode Failure时使用。这种情况下CMS退化为full gc，通过Serial Old实现老年代的空间整理。

Parallel Old收集器：Parallel Scavenge收集器的老年代版本，支持多线程并发收集。

- 用于老年代，采用标记整理算法。
- 服务端搭配Parallel Scavenge使用。
- 在注重吞吐量或者处理器资源较为稀缺的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器

CMS 收集器：一种以获取最短回收停顿时间为目标的收集器。

- 用于老年代，采用标记清除算法。
- 与之前的收集器不同，会通过并发的形式，减少用户线程的停顿，因此步骤也相对于前面的收集器更为复杂。共有四个步骤。
   - **初始标记**：**（STW）**记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快。
   - **并发标记**：从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行。
   - **重新标记**：**（STW）**通过增量更新，修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录。
   - **并发清除**：最后是并发清除阶段，清理删除掉标记阶段判断的已经死亡的 对象，由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的
- 有三个明显的问题：
   - **CMS收集器对处理器资源非常敏感**：即使并发执行，也是抢占了用户线程的CPU资源，降低了用户程序的执行速度。即使提供了增量式并发收集器，也是让收集时间变长，速度变慢的时间变长了，意义不大。
   - **无法处理浮动垃圾**：浮动垃圾即在并发标记与并发清理阶段，用户线程产生的垃圾对象。这部分需要六道下次垃圾收集过程进行收集，这意味着要预留足够内存空间提供给用户线程使用，因此CMS收集器不能像其他收集器那样等待到老年代几乎完全被填满了再进行收集，必须预留一部分空间供并发收集时的程序运作使用。**如果major gc 过程中出现老年代对象分配失败，就降级为full gc，垃圾收集器也退化为Serial Old，对老年代空间进行整理**。
   - 收集结束时会有大量空间碎片产生：
      - -XX：+UseCMS-CompactAtFullCollection。设置CMS收集器是否在完成垃圾收集后要进行一次内存碎片整理。默认开启。
      - -XX：CMSFullGCsBeforeCompaction。设置CMS收集器在完成若干次垃圾收集后在启动一次内存碎片整理，默认为0，即每次都整理。
- 注意CMS有三种GC行为：
   - major gc   标记清除
   - full gc 标记清除
   - full gc 标记整理
- CMS GC要决定是否在full GC时做压缩，会依赖几个条件。这个可以看看R大的详细说明。[https://hllvm-group.iteye.com/group/topic/28854](https://hllvm-group.iteye.com/group/topic/28854)


Garbage First（简称G1）收集器：设计者们希望做出一款能够建立起“停顿时间模型”（Pause Prediction Model）的收集器。

- **进行Mixed GC**。
- **基于Region的堆内存布局**：把连续的Java堆划分为多个大小相等的独立区域（Region），分别作为Eden空间、Survivor空间，或者老年代空间。还有一类特殊的Humongous区域，专门用来存储大对象，G1将其视为老年代。将Region作 为单次回收的最小单元，避免 在整个Java堆中进行全区域的垃圾收集，通过设立**优先级列表**，每次根据用户设定允许的收集停顿时间，优先处理回收价值收益最大的那些Region
- 存在的一些细节解决方案：
   - **跨Region引用对象如何解决**？
      - 每个Region都维护有自己的记忆集，这些记忆集会记录下别的Region 指向自己的指针，并标记这些指针分别在哪些卡页的范围之内，是一种**双向卡表**，由于region数量多，卡表的内存占用很大，大约相当于Java堆容量10%至20%的额外内存。
   - **在并发标记阶段如何保证收集线程与用户线程互不干扰地运行？**
      - 历史对象：通过原始快照（SATB）算法来避免用户线程改变对象引用关系。
      - 新对象：每一个Region设 计了两个名为TAMS（Top at Mark Start）的指针，将中间的部分用于并发回收过程中的新对象分配。
   - **怎样建立起可靠的停顿预测模型？**
      - G1收集器的停顿 预测模型是以衰减均值（Decaying Average）为理论基础来实现的。记录各个可测量的步骤花费的成本，并分析得 出平均值、标准偏差、置信度等统计信息。
- 运作过程
   - **初始标记**：（STW）标记一下GC Roots能直接关联到的对象，并且修改TAMS 指针的值
   - **并发标记**：从GC Root开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象
   - **最终标记**：（STW）处理并发阶段结束后仍遗留下来的最后那少量的SATB记录。
   - **筛选回收**：（STW）负责更新Region的统计数据，对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧 Region的全部空间。
- 从G1开始，最先进的垃圾收集器的设计导向都不约而同地变为追求能够应付应用的内存分配速率（Allocation Rate），而不追求一次把整个Java堆全部清理干净。
- G1 与 CMS相比，存在的劣势：
   - 内存：G1的卡表实现更为复杂，占用的内存空间大。CMS的卡表只有唯一一份，而且只需要处理老年代到新生代的引用。
   - 执行负载：CMS用写后屏障来更新维护卡表；而G1除了使用写后屏障来进行 同样的（由于G1的卡表结构复杂，其实是更烦琐的）卡表维护操作外，为了实现原始快照搜索 （SATB）算法，还需要使用写前屏障来跟踪并发时的指针变化情况。


衡量垃圾收集器的三项最重要的指标是：内存占用（Footprint）、吞吐量（Throughput）和延迟（Latency），三者共同构成了一个“不可能三角  ”。三者总体的表现会随技术进步而越来越好，但是 要在这三个方面同时具有卓越表现的“完美”收集器是极其困难甚至是不可能的，一款优秀的收集器通 常最多可以同时达成其中的两项。

![](https://image.tool4.fun/垃圾收集器与内存分配策略/20230425113555330.png)


Shenandoah收集器：一种能在任何堆内存大小下都可以把垃圾收集的停顿时间限制在十毫秒以内的垃圾收集器。

- 相较于G1的不同
   - 支持并发的整理算法
   - Shenandoah（目前）是默认不使用分代收集的
   - 用“连接矩阵”（Connection Matrix）的全局数据结构来记录跨Region的引用关系
- 运作过程的重要并发阶段：
   - 并发标记
   - **并发回收：通过读屏障和被称为“Brooks Pointers”的转发指针来解决**
   - 并发引用更新：按照内存物理地址的顺序，线性地搜索出引用类型，把旧值改为新值即可。
- **Brooks Pointers**：在原有对象布局结构的最前面统一增加一个新的引用字段
   - 带来一次额外的转向开销
   - 当对象拥有了一份新的副本时，只需要修改一处指针的值，即旧对象上转发指针的引用位置，使其指向新对象，便可将所有对该对象的访问转 发到新的副本上。
   - 并发场景通过CAS保证访问对象的正确性，避免修改对象字段时，修改到了旧对象上。
   - 需要覆盖全部对象访问操作，Shenandoah不得不同时设置读、写屏障去拦截。而数量庞大的读屏障带来的将是相对写屏障较大的性能开销。后续内存屏障只拦截对象中数据类型为引用类型的读写操作，而不去管原生数据类型等其他非引用字段的读写。

ZGC收集器：一款基于Region内存布局的，（暂时） 不设分代的，使用了读屏障、染色指针和内存多重映射等技术来实现可并发的标记-整理算法的，以低延迟为首要目标的一款垃圾收集器。

- 不支持分代，垃圾收集时扫描所有内存区域。
- **基于动态Region的堆内存布局：**动态创建和销毁，以及动态的区域容量大小。
   - 小型Region（Small Region）：容量固定为2MB，用于放置小于256KB的小对象。
   - 中型Region（Medium Region）：容量固定为32MB，用于放置大于等于256KB但小于4MB的对 象。
   - 大型Region（Large Region）：容量不固定，可以动态变化，但必须为2MB的整数倍，用于放置 4MB或以上的大对象。每个大型Region中只会存放一个大对象，这也预示着虽然名字叫作“大型 Region”，但它的实际容量完全有可能小于中型Region，最小容量可低至4MB。大型Region在ZGC的实现中是不会被重分配。
- 并发整理的实现-**染色指针：**
   - 染色指针是一种直接将少量额外的信息存储在指针上的技术。
   - 尽管Linux下64位指针的高18位不能用来寻址，但剩余的46位指针所能支持的64TB内存在今天仍然能够充分满足大型服务器的需要。鉴于此，ZGC的染色指针技术继续盯上了这剩下的46位指针宽度，将其**高4位提取出来存储四个标志信息**。
   - Java虚拟机作为一个普普通通的进程， 这样随意重新定义内存中某些指针的其中几位，操作系统是否支持？处理器是否支持？
      - Linux/x86-64平台上的ZGC使用了**多重映射（Multi-Mapping）**将多个不同的虚拟内存地址映射到同一 个物理内存地址上，这是一种多对一映射，意味着ZGC在虚拟内存中看到的地址空间要比实际的堆内 存容量来得更大。把染色指针中的标志位看作是地址的分段符，那只要将这些不同的地址段都映射到同一个物理内存空间，经过多重映射转换后，就可以使用染色指针正常进行寻址了
   - 优点：
      - 染色指针可以使得一旦某个Region的存活对象被移走之后，这个Region立即就能够被释放和重用 掉，而不必等待整个堆中所有指向该Region的引用都被修正后才能清理。
      - 大幅减少在垃圾收集过程中内存屏障的使用数量。
   - 劣势：直接导致**ZGC能够管理的内存不可以超过4TB**（2的42次幂）
- 运作过程：
   - **并发标记**：ZGC 的标记是在指针上而不是在对象上进行的，标记阶段会更新染色指针中的Marked 0、Marked 1标志位。其他的话，与G1、Shenandoah基本相同。
   - **并发预备重分配**：ZGC每次回收都会扫描所有的Region，用范围更大的扫描成本换取省去G1中记忆集的 维护成本。根据特定的查询条件统计得出 本次收集过程要清理哪些Region，将这些Region组成重分配集（Relocation Set）。
   - **并发重分配**：这个过程要把重分配集中的存活对象复制到新的Region上，并为重分配集中的每个Region维护一个**转发表（Forward Table）**，记录从旧对象到新对象的转向关系。
      - 得益于染色指针的支持，ZGC收集器能仅从引用上就明 确得知一个对象是否处于重分配集之中，如果用户线程此时并发访问了位于重分配集中的对象，这次 访问将会被预置的内存屏障所截获，然后立即根据Region上的转发表记录将访问转发到新复制的对象 上，并同时修正更新该引用的值，使其直接指向新对象，ZGC将这种行为称为**指针的“自愈”（SelfHealing）能力**。
      - 这样做的好处是只有第一次访问旧对象会陷入转发，也就是只慢一次。
   - **并发重映射**：修正整个堆中指向重分配集中旧对象的所有引用，这一点从目标角度看是与Shenandoah并发引用更新阶段一样的。但由于前面提到的自愈能力，ZGC很巧妙地把并发重映射 阶段要做的工作，合并到了下一次垃圾收集循环中的并发标记阶段里去完成。当所以指针都被修正后，原有的对象关系转发表就可以释放掉了。
- 存在的问题：
   - ZGC的这种不分代收集的选择也限制了它能承受的对象分配速率不会太高。有分代收集理论我们知道，大部分对象朝生夕灭，而ZGC却统一回收，即使收集过程停顿很短，但整个收集的过程很长，会出现浮动垃圾，这就让ZGC必须留着足够大的空间供新对象分配。
- 支持“NUMA-Aware”的内存分配：
   - 每个处理器核心所在的裸晶（DIE）都有 属于自己内存管理器所管理的内存，如果要访问被其他处理器核心管理的内存，就必须通过InterConnect通道来完成，这要比访问处理器的本地内存慢得多。在NUMA架构下，ZGC收集器会优先尝 试在请求线程当前所处的处理器的本地内存上分配对象，以保证高效内存访问
   - 之前仅有Parallel Scavenge支持。


### HotSpot 虚拟机如何分配对象内存

上面介绍了内存回收的问题，也基本上一直围绕着内存回收的一系列细节进行说明。但我们的内存管理只有回收吗？并不是。
> Java技术体系的自动内存管理，最根本的目标是自动化地解决两个问题：**自动给对象分配内存以 及自动回收分配给对象的内存**。

在上一章我们也提到了对象的内存布局以及对象的创建过程，其中提到了对象的分配内存空间，如何分配内存空间取决于内存是否规整，而这个又受到垃圾收集器的算法的影响。我们在上面已经介绍完了各个垃圾收集器，接下来是时候看看如何具体的为对象分配内存空间了。

在分代收集理论以及基于分代的收集器中，我们得知：

- **对象优先在Eden区分配。**当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC。又由Appel式回收可知，Minor GC 后我们期望的存活对象最大占用空间为一个Survivor区的容量。如果对象无法放入，则通过分配担保机制提前转移到老年代。
- **大对象直接进入老年代。**对象确实是优先在Eden区分配，但如果对象太大了，那最好直接分配在老年代。HotSpot虚拟机提供了-XX：PretenureSizeThreshold 参数，指定大于该设置值的对象直接在老年代分配，这样做的目的就是避免在Eden区及两个Survivor区之间来回复制，产生大量的内存复制操作。但参数只对Serial和ParNew两款新生代收集器有效。
- **长期存活的对象将进入老年代。**老年代的初衷本就是存放较长时间存活的对象。对象通常在Eden区里诞生，如果经过第一次 Minor GC后仍然存活，并且能被Survivor容纳的话，该对象会被移动到Survivor空间中，并且将其对象年龄设为1岁。对象在Survivor区中每熬过一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15，即第16次gc时），就会被晋升到老年代中。对象晋升老年代的年龄阈值，可以通过参数-XX： MaxTenuringThreshold设置。
- **动态对象年龄判定。**刚刚提到长期存活的对象进入老年代，但如果年龄设置的过大导致大量对象无法晋升或者，又或者好不容易晋升后，一会就被清理了，这样明显导致年轻代与老年代的分配不合理，老年代在这张场景下没有起到任何作用。如之前店铺能力系统的缓存GC频繁问题，其问题就在于1分钟的缓存对象，在55秒时进入老年代，解决方案是缩短或者延迟缓存时间，要么不进老年代，要么进老年代多用点时间。如果在Survivor空间中小于或等于某个年龄（假设为3）所有对象大小的总和大于 Survivor空间的-XX:TargetSurvivorRatio（50%），会将MaxTenuringThreshold 动态调整为3，并在下次GC中，将年龄大于3的对象就晋升老年代。
- **空间分配担保。**在发生Minor GC之前，虚拟机必须先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那这一次Minor GC可以确保是安全的。如果不成立，则虚拟机会先查看XX：HandlePromotionFailure参数的设置值是否允许担保失败（Handle Promotion Failure）；如果允许，那会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次Minor GC，尽管这次Minor GC是有风险的；如果小于，或者-XX： HandlePromotionFailure设置不允许冒险，那这时就要改为进行一次Full GC。
   - 在老年代连续最大可用空间不大于新生代所有对象总空间的前提下：差别在于开启担保，一次minor gc后会可能还会进行full gc。不开启则直接进行full gc。
```c
uint ageTable::compute_tenuring_threshold(size_t survivor_capacity) {
    //survivor_capacity是survivor空间的大小
    //desired_survivor_size就是动态年龄判断是否对象进入老年代的阈值
    //TargetSurvivorRatio：默认50
    size_t desired_survivor_size = (size_t)((((double) survivor_capacity)*TargetSurvivorRatio)/100);
    size_t total = 0;
    uint age = 1;
    while (age < table_size) {
        //sizes数组是每个年龄段对象大小
        //total就是年龄从小到大的对象占据的空间累加和
        total += sizes[age];
        //如果累加和大于阈值，就直接跳出循环，假设磁盘的age等于3吧
        if (total > desired_survivor_size) break;
        age++;
    }
    //MaxTenuringThreshold上限是15，现在age是3，那么result就是等于3
    uint result = age < MaxTenuringThreshold ? age : MaxTenuringThreshold;
    ...
    }

```


![](https://image.tool4.fun/垃圾收集器与内存分配策略/20230425113620935.png)

常见的GC问题：[https://tech.meituan.com/2020/11/12/java-9-cms-gc.html](https://tech.meituan.com/2020/11/12/java-9-cms-gc.html)
